<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>栈的几个应用场景 | 吹风的坚果</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.280e3266.css" as="style"><link rel="preload" href="/assets/js/app.598d8060.js" as="script"><link rel="preload" href="/assets/js/2.4f2e74d3.js" as="script"><link rel="preload" href="/assets/js/6.125d6abe.js" as="script"><link rel="prefetch" href="/assets/js/10.e79c846a.js"><link rel="prefetch" href="/assets/js/11.d336f07f.js"><link rel="prefetch" href="/assets/js/12.ebf97c23.js"><link rel="prefetch" href="/assets/js/13.f9fc41aa.js"><link rel="prefetch" href="/assets/js/14.1d241cc3.js"><link rel="prefetch" href="/assets/js/15.a81b04cd.js"><link rel="prefetch" href="/assets/js/16.dc1fed68.js"><link rel="prefetch" href="/assets/js/17.d6c05371.js"><link rel="prefetch" href="/assets/js/18.38605d93.js"><link rel="prefetch" href="/assets/js/19.5d79d441.js"><link rel="prefetch" href="/assets/js/20.51402678.js"><link rel="prefetch" href="/assets/js/21.ad3ac771.js"><link rel="prefetch" href="/assets/js/22.85fe41d1.js"><link rel="prefetch" href="/assets/js/23.78ae8a1e.js"><link rel="prefetch" href="/assets/js/24.4c1e0764.js"><link rel="prefetch" href="/assets/js/25.a6336fbd.js"><link rel="prefetch" href="/assets/js/26.7bc87b9c.js"><link rel="prefetch" href="/assets/js/27.a8bcba1d.js"><link rel="prefetch" href="/assets/js/28.2a827e55.js"><link rel="prefetch" href="/assets/js/3.3a22e7ff.js"><link rel="prefetch" href="/assets/js/4.03d8bd1f.js"><link rel="prefetch" href="/assets/js/5.6607a218.js"><link rel="prefetch" href="/assets/js/7.bb4679bc.js"><link rel="prefetch" href="/assets/js/8.584c5789.js"><link rel="prefetch" href="/assets/js/9.d75e3788.js">
    <link rel="stylesheet" href="/assets/css/0.styles.280e3266.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">吹风的坚果</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/protocol/" class="nav-link">
  协议
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  读书
</a></div><div class="nav-item"><a href="/insight/" class="nav-link">
  浅见
</a></div><div class="nav-item"><a href="/cncf/" class="nav-link">
  云原生
</a></div><div class="nav-item"><a href="/security/" class="nav-link">
  安全
</a></div><div class="nav-item"><a href="/alg/" class="nav-link router-link-active">
  算法
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/protocol/" class="nav-link">
  协议
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  读书
</a></div><div class="nav-item"><a href="/insight/" class="nav-link">
  浅见
</a></div><div class="nav-item"><a href="/cncf/" class="nav-link">
  云原生
</a></div><div class="nav-item"><a href="/security/" class="nav-link">
  安全
</a></div><div class="nav-item"><a href="/alg/" class="nav-link router-link-active">
  算法
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>算法与数据结构</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/alg/recursion.html" class="sidebar-link">聊一下递归</a></li><li><a href="/alg/stack.html" aria-current="page" class="active sidebar-link">栈的几个应用场景</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/alg/stack.html#_1-stack的由来" class="sidebar-link">1. stack的由来</a></li><li class="sidebar-sub-header"><a href="/alg/stack.html#_2-汇编语言中的调用栈" class="sidebar-link">2. 汇编语言中的调用栈</a></li><li class="sidebar-sub-header"><a href="/alg/stack.html#_3-c-虚拟机中的求值栈" class="sidebar-link">3. C#虚拟机中的求值栈</a></li><li class="sidebar-sub-header"><a href="/alg/stack.html#_4-树的遍历中使用栈" class="sidebar-link">4. 树的遍历中使用栈</a></li><li class="sidebar-sub-header"><a href="/alg/stack.html#_5-图的dfs深度遍历中使用栈" class="sidebar-link">5. 图的DFS深度遍历中使用栈</a></li><li class="sidebar-sub-header"><a href="/alg/stack.html#_6-拓扑排序中使用栈-其实也是图的dfs" class="sidebar-link">6. 拓扑排序中使用栈(其实也是图的DFS)</a></li><li class="sidebar-sub-header"><a href="/alg/stack.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/alg/stack.html#引用" class="sidebar-link">引用</a></li></ul></li><li><a href="/alg/b-tree.html" class="sidebar-link">零距离接地气的解析B树</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="栈的几个应用场景"><a href="#栈的几个应用场景" class="header-anchor">#</a> 栈的几个应用场景</h1> <p>对于栈，相信很多人都不陌生，本文尝试分析了栈的由来，总结了几种计算机中使用栈的场景，包括真实的调用栈，虚拟机的求值栈等， 加深对栈的理解与使用。</p> <h2 id="_1-stack的由来"><a href="#_1-stack的由来" class="header-anchor">#</a> 1. stack的由来</h2> <ul><li>stack是伴随着模块化编程而出现的，栈天生是与函数调用配合的，如下图所示方法<code>A</code> 调用<code>B</code>，<code>B</code>调用<code>C</code> <img src="/assets/img/turing-machine-call.f21066e6.jpg" alt="turing-matchine-call"></li> <li>我们可以将CPU想象为视野只有一个指令的会飞的蜗牛，它不停的根据<code>IP(Instruction Pointer)</code>指向的位置执行指令，所以想象该蜗牛的行动轨迹类似下图
<img src="/assets/img/stack-func-call-trace.09d7d031.jpg" alt="fun-call-trace"></li> <li>我们观察其中的P1和P2两个点，都是调用返回的位置，此处有两种使用方式（1）全局保存到某个位置（2）每个函数分配一块区域存放数据。如果全局保存的话，因为调用层级的不可预知，全局保存用到的空间无法预知，更合理的方式就是每个函数分配一块区域。如下图所示 <img src="/assets/img/stack-ret-adderss-save.a4be5504.jpg" alt="stack-ret-adderss-save"></li> <li>我们观察P1和P2的进入与出来的顺序就是
<ul><li>P1进入</li> <li>P2进入</li> <li>P2出来</li> <li>P1出来</li></ul></li> <li>上述只有P1和P2两个点，实际中可能是P1-Pn，这些点形成了一层一层的数据，并且是按照P1-&gt;Pn的顺序依次压入，按照Pn-&gt;P1的顺序依次弹出，这就是妥妥的栈。</li></ul> <h2 id="_2-汇编语言中的调用栈"><a href="#_2-汇编语言中的调用栈" class="header-anchor">#</a> 2. 汇编语言中的调用栈</h2> <ul><li>先看代码</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>int sum(int a, int b)
{
    return a + b;
}
int main()
{
   return sum(1,3);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>然后查看汇编代码</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>...
0000000000401106 &lt;sum&gt;:
  401106:       55                      push   %rbp
  401107:       48 89 e5                mov    %rsp,%rbp
  40110a:       89 7d fc                mov    %edi,-0x4(%rbp)
  40110d:       89 75 f8                mov    %esi,-0x8(%rbp)
  401110:       8b 55 fc                mov    -0x4(%rbp),%edx
  401113:       8b 45 f8                mov    -0x8(%rbp),%eax
  401116:       01 d0                   add    %edx,%eax
  401118:       5d                      pop    %rbp
  401119:       c3                      ret
000000000040111a &lt;main&gt;:
  40111a:       55                      push   %rbp
  40111b:       48 89 e5                mov    %rsp,%rbp
  40111e:       be 03 00 00 00          mov    $0x3,%esi
  401123:       bf 01 00 00 00          mov    $0x1,%edi
  401128:       e8 d9 ff ff ff          call   401106 &lt;sum&gt;
  40112d:       5d                      pop    %rbp
  40112e:       c3                      ret
  ...
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ul><li>通过gdb调试，使用si、x/32b、info r、b *main等逐步调试和查看寄存器和相关值，形成如下图，左侧为当前寄存器的值，右侧为栈的地址和值。
<img src="/assets/img/stack-call-frame-process.0e0d4492.jpg" alt="stack-call-frame-process.jpg"></li> <li>call、ret是成对出现的, call执行push下一条指令然后JUMP到目标为止，ret是Pop调用者压入位置的然后JUMP到该位置，所以跳转地址的push和pop是被集成到call和ret指令中的。Push逻辑上等于SUB RSP和MOV,Pop逻辑上等于MOV和ADD RSP，但是由于他们都是独立指令，所以硬件上能进行优化，减少流水线停顿。为了便于理解，画图如下
<img src="/assets/img/stack-instructive-division.ef23f054.jpg" alt="stack-instructive-division"></li> <li>RSP是随着Push和Pop指令自动变化的，RBP的变更需要维护，需要追赶RSP或者恢复到原来的位置</li></ul> <h2 id="_3-c-虚拟机中的求值栈"><a href="#_3-c-虚拟机中的求值栈" class="header-anchor">#</a> 3. C#虚拟机中的求值栈</h2> <ul><li>C#也是使用同样的逻辑代码</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>int Sum(int a, int b)
{
    return a + b;
}

int Main()
{
    return Sum(1,3);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>查看IL的指令</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>Main函数
.maxstack 2
.locals init (
    [0] int32
)
IL_0000: nop
IL_0001: ldc.i4.1
IL_0002: ldc.i4.3
IL_0003: call int32 Program::'&lt;&lt;Main&gt;$&gt;g__sum|0_0'(int32, int32)
IL_0008: stloc.0
IL_0009: br.s IL_000b
IL_000b: ldloc.0
IL_000c: ret
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>Sum函数
.maxstack 2
.locals init (
    [0] int32
)

IL_0000: nop
IL_0001: ldarg.0
IL_0002: ldarg.1
IL_0003: add
IL_0004: stloc.0
IL_0005: br.s IL_0007

IL_0007: ldloc.0
IL_0008: ret
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li>要想看懂上面的IL指令，我们从C#的<code>Method State</code>稍微做一下分析 <img src="/assets/img/stack-csharp-method-state.0748ada2.jpg" alt="stack-c#-method-state"></li> <li>每个方法都有一个Mothod State，都有<code>evaluation stack</code>、<code>local variable array</code>、<code>argument array</code>、<code>IP</code>和其他的一些信息，<code>.locals init</code>就是局部变量数组</li> <li>IL中的栈是求值栈，和调用栈不同，求值栈在每个方法中都有一个，而调用栈一般就只有一个</li> <li>stack和两个array都可以存放任意类型的数据</li> <li>ld开头的指令是load，st开头的指令是store，向stack搬运数据是load，从stack搬出数据是store</li> <li><code>Most CLI instructions retrieve their arguments from the evaluation stack and place their return values on the stack. Arguments to other methods and their return values are also placed on the evaluation stack.</code>  大多数的CLI指令都是从stack中取数据，计算后重新放入stack。 比如Add指令，就是从stack中pop两个数，计算后push结果。</li> <li>对于函数调用，调用call的时候也是按照参数的个数将数据从stack中pop出来，然后隐式调用<code>starg</code>指令将数据存储到另一个method的argument array中; 计算结束后将返回值重新放入到调用者的栈中 <img src="/assets/img/stack-csharp-call-pass-arguments.fcc0a800.jpg" alt="stack-csharp-call-pass-arguments"></li> <li>下面我们对上述过程进行逐句的解析</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>.maxstack 2
//初始化了最大长度为2的int32的局部变量数组
.locals init (
    [0] int32
)
//填充，没有执行意义
IL_0000: nop
//加载常数1到stack中，执行后栈中元素为[1]
IL_0001: ldc.i4.1
//加载常数3到stack中，执行后栈中元素为[1,3]
IL_0002: ldc.i4.3
//调用函数sum，将数字1和3取出，传入到sum的参数列表中，执行后栈中元素为[4]
IL_0003: call int32 Program::'&lt;&lt;Main&gt;$&gt;g__sum|0_0'(int32, int32)
//将栈顶元素4取出放入局部变量数组中的第0个位置，执行后栈为空
IL_0008: stloc.0
//直接跳转到IL_000b执行
IL_0009: br.s IL_000b
//将局部变量数组中的第0个位置的数字放入栈顶，执行后栈中的元素为[4]
IL_000b: ldloc.0
//返回，此时栈中只有一个元素，作为返回值
IL_000c: ret

////////////////////////////////////////
.maxstack 2
.locals init (
    [0] int32
)

IL_0000: nop
//将argument array的第一个参数加载栈中，执行后栈中元素为[1]
IL_0001: ldarg.0
//将argument array的第二个参数加载栈中，执行后栈中元素为[1,3]
IL_0002: ldarg.1
//add是二元操作指令，取出栈顶的2个元素1和3，相加后放入栈顶，执行后栈中元素为[4]
IL_0003: add
//将栈顶元素弹出放入本地变量数组的第0个位置，执行后栈为空
IL_0004: stloc.0
//直接跳到IL_0007执行
IL_0005: br.s IL_0007

//将本地变量数组的第0个位置放入栈顶，此处栈中元素为[4]
IL_0007: ldloc.0
//返回，栈中只有一个元素4，即将4返回给Main方法
IL_0008: ret
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><h2 id="_4-树的遍历中使用栈"><a href="#_4-树的遍历中使用栈" class="header-anchor">#</a> 4. 树的遍历中使用栈</h2> <ul><li>此处使用C#写了一个排序树，循环访问所有的数据，按照前序遍历顺序输出</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>public void Traverse(Action&lt;BinaryTreeNode&gt; visitor)
{
  var mystack = new MyStack&lt;BinaryTreeNode&gt;();
  if (Root != null)
  {
      circlePushNode(Root);
  }

  while (!mystack.IsEmpty())
  {
      var top = mystack.Pop();
      visitor(top);

      if (top.Right != null)
      {
          circlePushNode(top.Right);
      }
  }

  void circlePushNode(BinaryTreeNode node)
  {
      mystack.Push(node);
      while (node.Left != null)
      {
          mystack.Push(node.Left);
          node = node.Left;
      }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h2 id="_5-图的dfs深度遍历中使用栈"><a href="#_5-图的dfs深度遍历中使用栈" class="header-anchor">#</a> 5. 图的DFS深度遍历中使用栈</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>public void DFSWithStack()
{
    var stack = new MyStack&lt;int&gt;();
    var visisted = new HashSet&lt;int&gt;();

    stack.Push(Nodes.First().Vertex);
    visisted.Add(Nodes.First().Vertex);

    while (!stack.IsEmpty())
    {
        visitNode(stack, GetNode(stack.Pop()), visisted);
    }

    void visitNode(MyStack&lt;int&gt; stack, GraphNode&lt;int&gt; node, HashSet&lt;int&gt; visisted)
    {
        Console.WriteLine(node.Vertex);
        for (var i = 0; i &lt; node.Neighbors.Length; i++)
        {
            if (!visisted.Contains(node.Neighbors[i]))
            {
                stack.Push(node.Neighbors[i]);
                visisted.Add(node.Neighbors[i]);
            }
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="_6-拓扑排序中使用栈-其实也是图的dfs"><a href="#_6-拓扑排序中使用栈-其实也是图的dfs" class="header-anchor">#</a> 6. 拓扑排序中使用栈(其实也是图的DFS)</h2> <ul><li>拓扑排序就是对DAG(有向无环图)求得一个顶点的线性顺序</li> <li>深度遍历能够拓扑排序的理解：
<ol><li>深度路径的后一个节点决定于前一个节点，第一个节点决定了某个深度路径上的所有后续节点, 比如A-&gt;B-&gt;C-&gt;D-&gt;E, E要想被排序则ABCD都要先排序。</li> <li>让出度为0(或者邻居节点都已经进入最终结果栈)的节点依次进入最终结果栈<code>S</code>，<code>S</code>依次Pop得到有序结果；也就是说只有节点的所有邻居都已入栈节点才能入栈，也意味着它的邻居一定在它的后面被排序。</li></ol></li> <li><img src="/assets/img/stack-topo-sort-dag.f0323ed5.jpg" alt="stack-topo-sort-dag"></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>public class TopologicalSortWithDoubleStack
{
    public Dictionary&lt;int, List&lt;int&gt;&gt; Graph = new Dictionary&lt;int, List&lt;int&gt;&gt;()
    {
       { 0, new List&lt;int&gt;() {7,9} },
       { 1, new List&lt;int&gt;() {4,9} },
       { 2, new List&lt;int&gt;() {0,1,3}},
       { 3, new List&lt;int&gt;() {9}},
       { 4, new List&lt;int&gt;() {}},
       { 5, new List&lt;int&gt;() {0}},
       { 6, new List&lt;int&gt;() {4}},
       { 7, new List&lt;int&gt;() {6}},
       { 8, new List&lt;int&gt;() {2}},
       { 9, new List&lt;int&gt;() {6}},
    };
    
    public int[] Indegree = new int[10];
    private void InitializeIndegree()
    {
        for (int i = 0; i &lt; 10; i++)
        {
            Indegree[i] = Graph.Count(x =&gt; x.Value.Contains(i));
        }
    }

    public bool[] Visisted = new bool[10];
    private MyStack&lt;int&gt; visitPath = new();
    public MyStack&lt;int&gt; Result = new();

    public MyStack&lt;int&gt; VisitPath { get =&gt; visitPath; set =&gt; visitPath = value; }

    public void Sort()
    {
        InitializeIndegree();
        
        for (int i = 0;i &lt; Indegree.Length;i++)
        {
            if (Indegree[i] == 0)
            {
                VisitHeader(i);
            }
        }

        while(!Result.IsEmpty())
        {
            Console.WriteLine(Result.Pop());
        }
    }

    public void VisitHeader(int header)
    {
        visitVertex(header);

        while (!visitPath.IsEmpty()) 
        {
            var top = visitPath.Top();
            if (Graph[top].All(x =&gt; Visisted[x]))
            {
                Result.Push(top);
                visitPath.Pop();
            }
            else
            {
                for (int i = 0; i &lt; Graph[top].Count(); i++)
                {
                    var neightbor = Graph[top][i];
                    if (!Visisted[neightbor])
                    {
                        visitVertex(neightbor);
                    }
                }
            }
        }

        void visitVertex(int vertex)
        {
            var current = vertex;

            visitPath.Push(vertex);
            Visisted[vertex] = true;

            while (Graph[current].Any(x =&gt; !Visisted[x]))
            {
                var firstUnvisited = Graph[current].First(x =&gt; !Visisted[x]);
                visitPath.Push(firstUnvisited);
                Visisted[firstUnvisited] = true;
                current = firstUnvisited;
            }
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br></div></div><h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>从代码上看，算法中只要能用栈实现的地方都可以使用递归来做，对于上面的树、图的遍历，其实使用递归代码更简单，此处只是使用栈来实现。但是调用栈和求值栈是两种专用的场景，比如可以不用栈全用寄存器，也有基于寄存器的虚拟机比如Lua的虚拟机，但是一般来说指令会变得复杂一些。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>微信公众号为&quot;吹风的坚果&quot;，欢迎关注，定期更新优质的计算机文章。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="引用"><a href="#引用" class="header-anchor">#</a> 引用</h2> <ul><li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=net-9.0" target="_blank" rel="noopener noreferrer">C#-OpCode<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.ecma-international.org/wp-content/uploads/ECMA-335_6th_edition_june_2012.pdf" target="_blank" rel="noopener noreferrer">ECMA-335 CLI Standard<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/alg/recursion.html" class="prev">
        聊一下递归
      </a></span> <span class="next"><a href="/alg/b-tree.html">
        零距离接地气的解析B树
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.598d8060.js" defer></script><script src="/assets/js/2.4f2e74d3.js" defer></script><script src="/assets/js/6.125d6abe.js" defer></script>
  </body>
</html>
