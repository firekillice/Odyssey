<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>聊一下递归 | 吹风的坚果</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.280e3266.css" as="style"><link rel="preload" href="/assets/js/app.a58d46cf.js" as="script"><link rel="preload" href="/assets/js/2.fe1eedfa.js" as="script"><link rel="preload" href="/assets/js/18.dd58a776.js" as="script"><link rel="prefetch" href="/assets/js/10.cfd8ec07.js"><link rel="prefetch" href="/assets/js/11.bfaecfdb.js"><link rel="prefetch" href="/assets/js/12.3d5b7b8a.js"><link rel="prefetch" href="/assets/js/13.ba32c4a8.js"><link rel="prefetch" href="/assets/js/14.20c0ad27.js"><link rel="prefetch" href="/assets/js/15.dd93f4bb.js"><link rel="prefetch" href="/assets/js/16.357888f8.js"><link rel="prefetch" href="/assets/js/17.c18c107c.js"><link rel="prefetch" href="/assets/js/19.cd2f9a46.js"><link rel="prefetch" href="/assets/js/20.0a808641.js"><link rel="prefetch" href="/assets/js/21.66e28aad.js"><link rel="prefetch" href="/assets/js/22.f5987e31.js"><link rel="prefetch" href="/assets/js/23.10b4c64e.js"><link rel="prefetch" href="/assets/js/24.b400c0b1.js"><link rel="prefetch" href="/assets/js/25.5eae1d63.js"><link rel="prefetch" href="/assets/js/26.f2235e62.js"><link rel="prefetch" href="/assets/js/27.4d4233f6.js"><link rel="prefetch" href="/assets/js/28.d311b5aa.js"><link rel="prefetch" href="/assets/js/29.cb91b13f.js"><link rel="prefetch" href="/assets/js/3.11390a21.js"><link rel="prefetch" href="/assets/js/4.748295fe.js"><link rel="prefetch" href="/assets/js/5.55b94567.js"><link rel="prefetch" href="/assets/js/6.2fd028ab.js"><link rel="prefetch" href="/assets/js/7.12865be8.js"><link rel="prefetch" href="/assets/js/8.70384bac.js"><link rel="prefetch" href="/assets/js/9.fbfaf7b4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.280e3266.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">吹风的坚果</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/protocol/" class="nav-link">
  协议
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  读书
</a></div><div class="nav-item"><a href="/insight/" class="nav-link">
  浅见
</a></div><div class="nav-item"><a href="/cncf/" class="nav-link">
  云原生
</a></div><div class="nav-item"><a href="/security/" class="nav-link">
  安全
</a></div><div class="nav-item"><a href="/alg/" class="nav-link router-link-active">
  算法
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/protocol/" class="nav-link">
  协议
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  读书
</a></div><div class="nav-item"><a href="/insight/" class="nav-link">
  浅见
</a></div><div class="nav-item"><a href="/cncf/" class="nav-link">
  云原生
</a></div><div class="nav-item"><a href="/security/" class="nav-link">
  安全
</a></div><div class="nav-item"><a href="/alg/" class="nav-link router-link-active">
  算法
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>算法与数据结构</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/alg/recursion.html" aria-current="page" class="active sidebar-link">聊一下递归</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/alg/recursion.html#递归是个啥" class="sidebar-link">递归是个啥</a></li><li class="sidebar-sub-header"><a href="/alg/recursion.html#白话说一下" class="sidebar-link">白话说一下</a></li><li class="sidebar-sub-header"><a href="/alg/recursion.html#在计算机领域它是怎样的呢" class="sidebar-link">在计算机领域它是怎样的呢</a></li><li class="sidebar-sub-header"><a href="/alg/recursion.html#它为什么重要" class="sidebar-link">它为什么重要</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/alg/recursion.html#二叉树遍历-对比一下" class="sidebar-link">二叉树遍历，对比一下</a></li><li class="sidebar-sub-header"><a href="/alg/recursion.html#二分查找看一下" class="sidebar-link">二分查找看一下</a></li></ul></li><li class="sidebar-sub-header"><a href="/alg/recursion.html#什么场景下需要用到呢" class="sidebar-link">什么场景下需要用到呢？</a></li><li class="sidebar-sub-header"><a href="/alg/recursion.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/alg/stack.html" class="sidebar-link">栈的几个应用场景</a></li><li><a href="/alg/b-tree.html" class="sidebar-link">零距离接地气的解析B树</a></li><li><a href="/alg/rb-tree.html" class="sidebar-link">1. BST (Binary Search Tree)</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="聊一下递归"><a href="#聊一下递归" class="header-anchor">#</a> 聊一下递归</h1> <p>递归对很多程序员同学来说，可能是一个<code>熟悉而又陌生</code>的概念，因为上学的时候都会讲一个斐波那契数列，这是一个很好的递归的例子，可是毕业后大多数时候用的是循环迭代，递归用的场景比较少。笔者就是想擦拭一下递归这个概念，让它清晰起来。</p> <h2 id="递归是个啥"><a href="#递归是个啥" class="header-anchor">#</a> 递归是个啥</h2> <ul><li>Wiki上的定义是,<code>在数学与计算机科学中，是指在函数的定义中使用函数自身的方法</code></li> <li>这个定义比较干燥，我们把它展开说</li></ul> <h2 id="白话说一下"><a href="#白话说一下" class="header-anchor">#</a> 白话说一下</h2> <ol><li>你站在两个镜子中间，你在每个镜子中能看到几个自己呢</li> <li>俄罗斯套娃</li> <li>最近听樊登读书，经常说的一个词 <code>自我引用</code>，今天的表現都是前一天的結果
这些都可以认为是递归的例子，抽象的说，就是<code>一个模式引用了同样的模式</code>。</li></ol> <h2 id="在计算机领域它是怎样的呢"><a href="#在计算机领域它是怎样的呢" class="header-anchor">#</a> 在计算机领域它是怎样的呢</h2> <ol><li>给它祛魅，实现上就是<code>一个函数调用自己</code>，底层汇编使用CALL指令，CPU才不管调用的是啥，只管往前跑。</li> <li>计算机中并没有一个<code>递归</code>的关键字，<code>递归只是一种思想</code>，一种解决问题的<code>方法论</code>，但是几乎所有的语言都支持函数自己调用自己，也就是了说提供递归实现的基础。</li> <li>计算机中需要递归的场景都可以转为迭代，也就是说在资源允许的情况下(栈不溢出)，迭代和递归是可以相互转换的，但是如果想让编译器自动实现转化，就需要实现<code>尾递归</code></li></ol> <ul><li>N个1相加(什么玩意，使用循环不好么)</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>int f(int n) =&gt; n &gt; 0 ? f(n - 1) + 1 : 0;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>整数数组的数字之和(什么玩意，使用循环不好么+1)</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>int Sum(int[] array, int length) =&gt; (length &gt; 1 ? Sum(array, length - 1) : array[0]) + array[length - 1];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="它为什么重要"><a href="#它为什么重要" class="header-anchor">#</a> 它为什么重要</h2> <p>它能够解决一下较为复杂的问题</p> <h3 id="二叉树遍历-对比一下"><a href="#二叉树遍历-对比一下" class="header-anchor">#</a> 二叉树遍历，对比一下</h3> <ul><li>使用迭代的方式，大概会写成下面的样子</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>public void TraverseNode()
{
  var stack = new MyStack&lt;BinaryTreeNode&gt;();
    void pushLeft(BinaryTreeNode node)
    {
        var current = node;
        stack.Push(current);

        while (current.Left != null)
        {
            stack.Push(current.Left);
            current = current.Left;
        }
    }

    if (Root != null)
    {
        pushLeft(Root);
    }

    while (!stack.IsEmtpy())
    {
        var current = stack.Pop();
        Console.WriteLine(current.Value);
        if (current.Right != null)
        {
            pushLeft(current.Right);
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><ul><li>使用递归的方式</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>void TraverseNode(BinaryTreeNode parent)
{
    if (parent.Left != null)
    {
        TraverseNode(parent.Left);
    }
    Console.WriteLine(parent.Value);
    if (parent.Right != null)
    {
        TraverseNode(parent.Right);
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>wtf, 太清爽了吧，其实说白了，这种遍历需要一个<code>栈</code>来存储路径，只不过是第一种方式是<code>程序员自己维护</code>，第二种是通过<code>递归的方式让系统去维护</code>。</p> <h3 id="二分查找看一下"><a href="#二分查找看一下" class="header-anchor">#</a> 二分查找看一下</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>int search(int[] orderedArray, int start, int end, int value)
{
    if (start == end)
    {
        if (orderedArray[start] == value)
        {
            return start;
        }
        else
        {
            return -1;
        }
    }

    var middle = (end + start) / 2;
    if (orderedArray[middle] &gt; value)
    {
        return search(orderedArray, start, middle - 1, value);
    }
    else if (orderedArray[middle] &lt; value)
    {
        return search(orderedArray, middle + 1, end, value);
    }
    else
    {
        return middle;
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>上面的二分换成迭代试试，呵呵。</p> <h2 id="什么场景下需要用到呢"><a href="#什么场景下需要用到呢" class="header-anchor">#</a> 什么场景下需要用到呢？</h2> <ul><li>其实计算机中使用迭代把递归能干活的抢走了，或者说能用循环的场景就用循环了。循环是一种<code>线性处理模式</code>，
<img src="/assets/img/iteration-line.f7f31cad.png" alt="iteration-line">，这种模式能解决大多数的问题，因为迭代或者说循环更容易理解一下，想想一下，如果向一年级小朋友介绍循环，估计三四句话小朋友就明白了，ok，我们讲递归，全体小朋友瞪大了眼睛。</li> <li>我的理解是，<code>树形</code>的问题可以考虑使用递归处理，怎么说呢，如下图，我称它为递归树,很多复杂问题可以分解为相似的问题，分解若干次后，<code>在终止条件处有明确的解</code>。
<img src="/assets/img/recursion-tree.b3a24c2f.png" alt="recursion-tree"></li> <li>有了递归，那什么时候用递归，什么时候用迭代呢？我个人觉得就是，能用迭代就用迭代，用迭代明显变的复杂的场景就用递归，关键在于问题的复杂度，我猜没人愿意计算N个1之和写成<code>int f(int n) =&gt; n &gt; 0 ? f(n - 1) + 1 : 0;</code>这个样子吧，也没人愿意使用一个栈来处理二叉树的遍历问题。</li> <li>切记，递归一定有一个出口，也就是终止条件，不然递归会<code>进入无尽的黑渊</code></li> <li>使用递归重要的是什么，找到递归模式，一个是找到<code>子问题</code>，一个是找到<code>出口</code>。</li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>递归是一种解决问题的思想，计算机中就是函数调用自己，但是需要有个出口，不然就闷死了。递归什么时候用呢，在合适的复杂度的时候使用。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>微信公众号为“吹风的坚果”，欢迎关注，定期更新优质的计算机文章。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/alg/stack.html">
        栈的几个应用场景
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a58d46cf.js" defer></script><script src="/assets/js/2.fe1eedfa.js" defer></script><script src="/assets/js/18.dd58a776.js" defer></script>
  </body>
</html>
