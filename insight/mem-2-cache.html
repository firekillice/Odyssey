<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>内存和缓存的如何聊天 | 吹风的坚果</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.280e3266.css" as="style"><link rel="preload" href="/assets/js/app.598d8060.js" as="script"><link rel="preload" href="/assets/js/2.4f2e74d3.js" as="script"><link rel="preload" href="/assets/js/10.e79c846a.js" as="script"><link rel="prefetch" href="/assets/js/11.d336f07f.js"><link rel="prefetch" href="/assets/js/12.ebf97c23.js"><link rel="prefetch" href="/assets/js/13.f9fc41aa.js"><link rel="prefetch" href="/assets/js/14.1d241cc3.js"><link rel="prefetch" href="/assets/js/15.a81b04cd.js"><link rel="prefetch" href="/assets/js/16.dc1fed68.js"><link rel="prefetch" href="/assets/js/17.d6c05371.js"><link rel="prefetch" href="/assets/js/18.38605d93.js"><link rel="prefetch" href="/assets/js/19.5d79d441.js"><link rel="prefetch" href="/assets/js/20.51402678.js"><link rel="prefetch" href="/assets/js/21.ad3ac771.js"><link rel="prefetch" href="/assets/js/22.85fe41d1.js"><link rel="prefetch" href="/assets/js/23.78ae8a1e.js"><link rel="prefetch" href="/assets/js/24.4c1e0764.js"><link rel="prefetch" href="/assets/js/25.a6336fbd.js"><link rel="prefetch" href="/assets/js/26.7bc87b9c.js"><link rel="prefetch" href="/assets/js/27.a8bcba1d.js"><link rel="prefetch" href="/assets/js/28.2a827e55.js"><link rel="prefetch" href="/assets/js/3.3a22e7ff.js"><link rel="prefetch" href="/assets/js/4.03d8bd1f.js"><link rel="prefetch" href="/assets/js/5.6607a218.js"><link rel="prefetch" href="/assets/js/6.125d6abe.js"><link rel="prefetch" href="/assets/js/7.bb4679bc.js"><link rel="prefetch" href="/assets/js/8.584c5789.js"><link rel="prefetch" href="/assets/js/9.d75e3788.js">
    <link rel="stylesheet" href="/assets/css/0.styles.280e3266.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">吹风的坚果</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/protocol/" class="nav-link">
  协议
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  读书
</a></div><div class="nav-item"><a href="/insight/" class="nav-link router-link-active">
  浅见
</a></div><div class="nav-item"><a href="/cncf/" class="nav-link">
  云原生
</a></div><div class="nav-item"><a href="/security/" class="nav-link">
  安全
</a></div><div class="nav-item"><a href="/alg/" class="nav-link">
  算法
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/protocol/" class="nav-link">
  协议
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  读书
</a></div><div class="nav-item"><a href="/insight/" class="nav-link router-link-active">
  浅见
</a></div><div class="nav-item"><a href="/cncf/" class="nav-link">
  云原生
</a></div><div class="nav-item"><a href="/security/" class="nav-link">
  安全
</a></div><div class="nav-item"><a href="/alg/" class="nav-link">
  算法
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>浅见</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/insight/va-2-pa.html" class="sidebar-link">用虚拟地址如何找到物理地址</a></li><li><a href="/insight/mem-2-cache.html" aria-current="page" class="active sidebar-link">内存和缓存的如何聊天</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/insight/mem-2-cache.html#说说缓存" class="sidebar-link">说说缓存</a></li><li class="sidebar-sub-header"><a href="/insight/mem-2-cache.html#说说内存-以ddr内存为例" class="sidebar-link">说说内存(以DDR内存为例)</a></li><li class="sidebar-sub-header"><a href="/insight/mem-2-cache.html#它俩如何聊天" class="sidebar-link">它俩如何聊天</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/insight/mem-2-cache.html#参考" class="sidebar-link">参考</a></li></ul></li></ul></li><li><a href="/insight/hdd-2-mem.html" class="sidebar-link">磁盘和内存如何聊天</a></li><li><a href="/insight/kafka.html" class="sidebar-link">kafka 一篇入魂</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="内存和缓存的如何聊天"><a href="#内存和缓存的如何聊天" class="header-anchor">#</a> 内存和缓存的如何聊天</h1> <p>本文将首先介绍缓存的基本概念，然后详细描述内存的结构与工作原理，最后阐述缓存和内存之间的数据通信方式。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>不做特殊说明的话，本文涉及到的内容都基于x86体系
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="说说缓存"><a href="#说说缓存" class="header-anchor">#</a> 说说缓存</h2> <h4 id="为什么需要缓存"><a href="#为什么需要缓存" class="header-anchor">#</a> 为什么需要缓存</h4> <p>从<a href="https://colin-scott.github.io/personal_website/research/interactive_latency.html" target="_blank" rel="noopener noreferrer">延迟对比<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中看，2020年的设备延迟对比如下:</p> <table><thead><tr><th>名称</th> <th>延迟</th> <th>对比</th></tr></thead> <tbody><tr><td>寄存器</td> <td>1滴答</td> <td>如果是2GHz主频的CPU，则时间为1/2G=0.5ns</td></tr> <tr><td>L1缓存</td> <td>1ns</td> <td></td></tr> <tr><td>L2缓存</td> <td>4ns</td> <td>与L1缓存相比，差不多是<strong>声速</strong>(1224km/h)和<strong>高铁</strong>(300km/h)的差异， 4倍</td></tr> <tr><td>Memory</td> <td>100ns</td> <td>与L2缓存相比，差不多是<strong>高铁</strong>(300km/h)和<strong>跑步</strong>(12km/h)的差别，25倍</td></tr> <tr><td>SSD</td> <td>150μs</td> <td>与内存相比，慢了1500倍，差不多是<strong>跑步</strong>与<strong>蜗牛</strong>的区别</td></tr> <tr><td>HDD</td> <td>10ms</td> <td>与内存相比, 慢了10万倍，差不多是<strong>战斗机</strong>(2500km/h)和<strong>乌龟</strong>(20m/h)的区别；与SSD相比，慢了60倍，差不多是<strong>高铁</strong>与<strong>走路</strong>的区别</td></tr></tbody></table> <p>可以看出，如果没有L1、L2等缓存的话，CPU的绝大多数时间将耗费在等待内存传输数据上。为了解决这一问题并提高处理速度，各种层次的缓存被引入到系统中，以减少延迟。</p> <h4 id="直观感受一下linux的缓存"><a href="#直观感受一下linux的缓存" class="header-anchor">#</a> 直观感受一下Linux的缓存</h4> <p>Linux下Cache Line的信息在/sys/devices/system/cpu/cpu[0-N]/cache/index[0-3]这个目录下，目录下的信息如下表所示:</p> <table><thead><tr><th>文件名</th> <th>解释</th></tr></thead> <tbody><tr><td>coherency_line_size</td> <td>每个缓存行的大小</td></tr> <tr><td>size</td> <td>缓存总大小</td></tr> <tr><td>level</td> <td>缓存等级</td></tr> <tr><td>type</td> <td>缓存类型(Data、Instruction、Unified)</td></tr> <tr><td>shared_cpu_list</td> <td>哪几个CPU共享该缓存</td></tr> <tr><td>number_of_sets</td> <td>缓存的组数</td></tr> <tr><td>ways_of_associativity</td> <td>每组有多少路</td></tr></tbody></table> <p>每个CPU对应4个level的cache，一级缓存的指令和数据缓存，二级缓存和三级缓存。如果number_of_sets=64，ways_of_associativity=12，coherency_line_size=64，则size应该等于number_of_sets * ways_of_associativity * coherency_line_size = 64 * 12 * 64 = 48K。
这里需要特别提出的是，通常情况下，L1、L2、L3使用的是Inclusive方式(如下图所示)，但是有的架构设计采用的是Non-Inclusive方式，即两层之间互相不包含数据，比如Intel Skylake的L3 Cache就不包含L2 Cache的数据，这里取决于架构设计。
<img src="/assets/img/inclusive-cache-hierarchy.aef1a776.png" alt="inclusive">
Inclusive
<img src="/assets/img/non-inclusive-cache-hierarchy.6b636531.png" alt="non-inclusive">
L3为Non-Inclusive</p> <h2 id="说说内存-以ddr内存为例"><a href="#说说内存-以ddr内存为例" class="header-anchor">#</a> 说说内存(以DDR内存为例)</h2> <h4 id="名词解释"><a href="#名词解释" class="header-anchor">#</a> 名词解释</h4> <ul><li>DDR SDRAM: Double Data Rate Synchronous Dynamic Random-Access Memory
<ul><li>Double Data Rate的意思是可以在时钟周期的上沿和下沿传递两次数据</li> <li>Dynamic的意思是因为电容的原因需要不停地充电</li> <li>Random-Access就是支持随机访问，如同数组一样可以随机访问，比如树形结构就不支持随机访问</li> <li>Synchronous的意思是，内存控制器(目前已嵌入到了CPU中，早期计算机是放在北桥芯片中)和内存条之间使用相同的时钟新号进行数据传输，确保他们在时序上协同工作</li></ul></li> <li>DIMM(Dual-Inline-Memory-Modules) 双列直插式存储模块，就是内存条本身，两面都有颗粒</li> <li>SIMM(Single-Inline-Memory-Module) 单列直插式内存模块，也是内存条，单面有颗粒</li> <li>通道，就是CPU与内存之间的通路，有单通道、三通道、双通道、四通道等，每个通道都有独立的总线</li> <li>Cell: 最小的存储单元，存储一个bit的信息，DRAM的一个cell由一个Transistor和一个Capacitor组成，SRAM则最少需要6个Transistor</li> <li>Supercell: 若干个cell组成一个supercell，可能是8bit、16bit等，<strong>它是内存寻址的最小单元</strong>, <strong>注意工业领域并没有看到Cell和Supercell相关的称呼</strong>，</li> <li>Rank: <strong>提供64位数据能力</strong>，这就是内存的1R或者2R</li> <li>Bank: <strong>一个基本的数据矩阵管理单元</strong>，我查看了<a href="https://www.kingston.com/cn/memory" target="_blank" rel="noopener noreferrer">金士顿<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的相关产品，服务器使用的内存颗粒使用了多bank，台式机/笔记本上内存大多数是一个bank</li></ul> <h4 id="dram内部寻址过程"><a href="#dram内部寻址过程" class="header-anchor">#</a> DRAM内部寻址过程</h4> <ul><li><img src="/assets/img/dram-access-model.8e9ed833.gif" alt="dram-access-model">， 该动画描述了一个行地址和列地址都是2bit，输出结果为8bit的存储模块的执行过程，图中每个格子是一个supercell</li> <li>如果要输出64bit的数据，只需要将多个这样的模块串联即可。<img src="/assets/img/multi-dram.cf029c2e.png" alt="multi-dram"></li> <li>在实际中，需要看一个Chip提供多少位的数据</li> <li>举例子<a href="https://www.kingston.com/datasheets/KVR64A52BD8-64.pdf" target="_blank" rel="noopener noreferrer">金士顿的一款台式机内存条<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，摘录以下片段来看</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>KVR64A52BD8-64 64GB 2Rx8 8G x 64-Bit PC5-6400 CL52 288-Pin CUDIMM
   This document describes ValueRAM's KVR64A52BD8-64 is a 8G x64-bit (64GB) DDR5-6400 CL52 Clocked Unbuffered DIMMs(CUDIMMs), 2Rx8, memory module, based on sixteen 4G x 8-bit
FBGA components and one Clock Driver (CKD). 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>从该描述中可以看出，2Rx8 该内存条有个2个Rank，即可以提供两组64地址，8代表每个芯片颗粒是8bit，即最小寻址单元为8bit；8G x 64-bit是有8G个64bit的提供数据的能力，即8<em>64/8=64G；sixteen 4G x 8-bit
FBGA标识有16个内存颗粒，每个颗粒能提供4G</em>8bit=4GB的数据量，16*4=64GB。另外从2Rx8中也可以算出来16个颗粒，因为有2组，每组需要64/8个颗粒。</p> <ul><li>前面提到了一些概念，他们之间的关系如下，一个内存条可能包含1-n个rank，一个rank中可能有bank或者没有bank，没有bank可以认为一个芯片是一个bank，bank内部是二维矩阵，内存寻址在bank中进行，寻址的最小单位就是supercell或者芯片的位宽。</li> <li><strong>程序员眼中的8B(64bit)大概率上分布在不同的芯片中</strong>,除非使用了具有64bit位宽的内存颗粒。</li></ul> <h4 id="地址如何转化为对内存的具体访问"><a href="#地址如何转化为对内存的具体访问" class="header-anchor">#</a> 地址如何转化为对内存的具体访问</h4> <ul><li>当内存控制器接受到物理地址后，会对地址进行映射，即DDR Memory Mapping，确定地址所在的channel、rank、bank、row、column</li> <li>遗憾的是，Intel并没有公开这种映射关系，参见<a href="https://depletionmode.com/ram-mapping.html" target="_blank" rel="noopener noreferrer">What's in an Address: Understanding DDR Memory Mapping<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="https://lackingrhoticity.blogspot.com/2015/05/how-physical-addresses-map-to-rows-and-banks.html" target="_blank" rel="noopener noreferrer">How physical addresses map to rows and banks in DRAM<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，只能进行逆向工程</li> <li>物理地址信息里一定包含了channel、rank、bank、row、column这些信息，至于如何组织的，得具体去分析。</li></ul> <h2 id="它俩如何聊天"><a href="#它俩如何聊天" class="header-anchor">#</a> 它俩如何聊天</h2> <p>有了缓存之后，CPU和内存之间的物理拓扑大体如下：
<img src="/assets/img/mem-cache-layout.77df4578.png" alt="mem-cache-layout">，内存控制器已经被集成到CPU中，CPU直接通过内存总线或者说内存通道和内存通信。
我们知道物理地址是一个线性空间，而且比缓存要大很多，缓存如何与内存关联在一起呢，就是使用地址映射，具体如何映射呢，主要有以下三种方式。</p> <h4 id="映射机制"><a href="#映射机制" class="header-anchor">#</a> 映射机制</h4> <ul><li><strong>直接映射</strong> <ul><li>一个内存地址只能被映射到<strong>特定</strong>缓存行中，这种方式缺点就是可能数据会被踢出太快，这也是最简单的方式，因为是1对1的</li></ul></li> <li><strong>完全关联缓存</strong> <ul><li>某一个内存地址可以被映射到<strong>任意</strong>一个缓存行，这种方式做数据替换很麻烦或者不现实，这个是1对N的</li></ul></li> <li><strong>组相联的方式</strong> <ul><li>某一个内存地址可以被映射到<strong>一组缓存</strong>, 这也是目前使用最多的缓存映射方式，具体应该如何映射，我们将物理地址分为Tag | Index | Offset四个部分，下图以16bit的地址为例，内存按照8个字节分组，Offset部分占用3bit，cache line一共4组，Index占用2bit，剩下的部分为Tag，头部追加valid字段，这样只要很少的空间代价(Tag+Valid)就能缓存8B的数据。<img src="/assets/img/cacheline-layout.3371ba04.png" alt="cacheline-layout">。</li></ul></li></ul> <h4 id="最后但重要"><a href="#最后但重要" class="header-anchor">#</a> 最后但重要</h4> <p>目前，主流机器的总线宽度为64bit，而内存与CPU之间的最小传输单位是cache line（通常为64B）。即使需要访问一个字节的数据，CPU也会加载整个cache line到缓存中。以下几点需要特别注意：</p> <ul><li><strong>L1缓存优先读取</strong>: CPU通常从L1缓存中读取数据。如果发生cache miss，数据会从较低级的缓存（如L2或L3）加载到L1缓存，或者直接绕过L1缓存加载到L2或更低级缓存。不过，绕过L1会增加布线复杂度。</li> <li><strong>缓存行传输</strong>: 64B的数据需要通过64bit总线进行8次传输（每次8bit）。但并非必须等待8次传输完成才能通知CPU，具体取决于硬件设计。</li> <li><strong>地址对齐</strong>: 传输到地址总线的地址通常会对齐到缓存行边界，Offset部分为0。在64bit总线中，地址的后6位必须为0，在32bit总线中，后5位为0。参见<a href="https://cdrdv2.intel.com/v1/dl/getContent/671200" target="_blank" rel="noopener noreferrer">Intel® 64 and IA-32 Architectures Software Developer’s Manual<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>For Intel Core i7 processors and processors based on Intel Core, Intel Atom, and Intel NetBurst microarchitectures,Intel Core Duo, Intel Core Solo and Pentium M processors, the cache lines for the L1 and L2 caches (and L3 caches if supported) are 64 bytes wide. The processor always reads a cache line from system memory beginning on a 64-byte boundary. (A 64-byte aligned cache line begins at an address with its 6 least-significant bits clear.) 
The L1 and L2 cache lines in the P6 family and Pentium processors are 32 bytes wide, with cache line reads from system memory beginning on a 32-byte boundary (5 least-significant bits of a memory address clear.)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h3> <ul><li><a href="https://www.cse.cuhk.edu.hk/~mcyang/csci2510/2223T1/Lec08%20Memory%20Performance.pdf" target="_blank" rel="noopener noreferrer">香港中文大学-CSCI2510-memory performance<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www3.cs.stonybrook.edu/~amione/CSE320_Course/materials/lectures/Lecture13_The_Memory_Hierarchy.pdf" target="_blank" rel="noopener noreferrer">Lecture13_The_Memory_Hierarchy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/18213-f23/www/lectures/09-memory-hierarchy.pdf" target="_blank" rel="noopener noreferrer">09-memory-hierarchy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://cdrdv2.intel.com/v1/dl/getContent/671200" target="_blank" rel="noopener noreferrer">Intel® 64 and IA-32 Architectures Software Developer’s Manual<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://lwn.net/Articles/250967/" target="_blank" rel="noopener noreferrer">What every programmer should know about memory<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/insight/va-2-pa.html" class="prev">
        用虚拟地址如何找到物理地址
      </a></span> <span class="next"><a href="/insight/hdd-2-mem.html">
        磁盘和内存如何聊天
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.598d8060.js" defer></script><script src="/assets/js/2.4f2e74d3.js" defer></script><script src="/assets/js/10.e79c846a.js" defer></script>
  </body>
</html>
