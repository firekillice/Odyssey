<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>用虚拟地址如何找到物理地址 | 吹风的坚果</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.280e3266.css" as="style"><link rel="preload" href="/assets/js/app.598d8060.js" as="script"><link rel="preload" href="/assets/js/2.4f2e74d3.js" as="script"><link rel="preload" href="/assets/js/12.ebf97c23.js" as="script"><link rel="prefetch" href="/assets/js/10.e79c846a.js"><link rel="prefetch" href="/assets/js/11.d336f07f.js"><link rel="prefetch" href="/assets/js/13.f9fc41aa.js"><link rel="prefetch" href="/assets/js/14.1d241cc3.js"><link rel="prefetch" href="/assets/js/15.a81b04cd.js"><link rel="prefetch" href="/assets/js/16.dc1fed68.js"><link rel="prefetch" href="/assets/js/17.d6c05371.js"><link rel="prefetch" href="/assets/js/18.38605d93.js"><link rel="prefetch" href="/assets/js/19.5d79d441.js"><link rel="prefetch" href="/assets/js/20.51402678.js"><link rel="prefetch" href="/assets/js/21.ad3ac771.js"><link rel="prefetch" href="/assets/js/22.85fe41d1.js"><link rel="prefetch" href="/assets/js/23.78ae8a1e.js"><link rel="prefetch" href="/assets/js/24.4c1e0764.js"><link rel="prefetch" href="/assets/js/25.a6336fbd.js"><link rel="prefetch" href="/assets/js/26.7bc87b9c.js"><link rel="prefetch" href="/assets/js/27.a8bcba1d.js"><link rel="prefetch" href="/assets/js/28.2a827e55.js"><link rel="prefetch" href="/assets/js/3.3a22e7ff.js"><link rel="prefetch" href="/assets/js/4.03d8bd1f.js"><link rel="prefetch" href="/assets/js/5.6607a218.js"><link rel="prefetch" href="/assets/js/6.125d6abe.js"><link rel="prefetch" href="/assets/js/7.bb4679bc.js"><link rel="prefetch" href="/assets/js/8.584c5789.js"><link rel="prefetch" href="/assets/js/9.d75e3788.js">
    <link rel="stylesheet" href="/assets/css/0.styles.280e3266.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">吹风的坚果</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/protocol/" class="nav-link">
  协议
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  读书
</a></div><div class="nav-item"><a href="/insight/" class="nav-link router-link-active">
  浅见
</a></div><div class="nav-item"><a href="/cncf/" class="nav-link">
  云原生
</a></div><div class="nav-item"><a href="/security/" class="nav-link">
  安全
</a></div><div class="nav-item"><a href="/alg/" class="nav-link">
  算法
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/protocol/" class="nav-link">
  协议
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  读书
</a></div><div class="nav-item"><a href="/insight/" class="nav-link router-link-active">
  浅见
</a></div><div class="nav-item"><a href="/cncf/" class="nav-link">
  云原生
</a></div><div class="nav-item"><a href="/security/" class="nav-link">
  安全
</a></div><div class="nav-item"><a href="/alg/" class="nav-link">
  算法
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>浅见</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/insight/va-2-pa.html" aria-current="page" class="active sidebar-link">用虚拟地址如何找到物理地址</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/insight/va-2-pa.html#从一条指令说起" class="sidebar-link">从一条指令说起</a></li><li class="sidebar-sub-header"><a href="/insight/va-2-pa.html#什么是虚拟内存" class="sidebar-link">什么是虚拟内存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/insight/va-2-pa.html#why有虚拟内存" class="sidebar-link">Why有虚拟内存</a></li><li class="sidebar-sub-header"><a href="/insight/va-2-pa.html#paging" class="sidebar-link">Paging</a></li><li class="sidebar-sub-header"><a href="/insight/va-2-pa.html#页表入口" class="sidebar-link">页表入口</a></li><li class="sidebar-sub-header"><a href="/insight/va-2-pa.html#执行机构-mmu-memory-management-unit-地址管理单元" class="sidebar-link">执行机构: MMU(Memory Management Unit)地址管理单元</a></li></ul></li><li class="sidebar-sub-header"><a href="/insight/va-2-pa.html#执行流程" class="sidebar-link">执行流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/insight/va-2-pa.html#总结" class="sidebar-link">总结</a></li></ul></li></ul></li><li><a href="/insight/mem-2-cache.html" class="sidebar-link">内存和缓存的如何聊天</a></li><li><a href="/insight/hdd-2-mem.html" class="sidebar-link">磁盘和内存如何聊天</a></li><li><a href="/insight/kafka.html" class="sidebar-link">kafka 一篇入魂</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="用虚拟地址如何找到物理地址"><a href="#用虚拟地址如何找到物理地址" class="header-anchor">#</a> 用虚拟地址如何找到物理地址</h1> <h2 id="从一条指令说起"><a href="#从一条指令说起" class="header-anchor">#</a> 从一条指令说起</h2> <p>mov rax, [0x12345678]，我们都知道这条指令是从地址0x12345678加载数据的到RAX寄存器，那么这个地址是什么地址呢？对是虚拟地址，通过该虚拟地址如何找到内存所对应的位置呢，本文尝试去回答这个问题。</p> <h2 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="header-anchor">#</a> 什么是虚拟内存</h2> <p>虚拟内存是操作系统提供的一种内存管理机制，它允许程序拥有连续的虚拟地址空间，而不管物理内存的实际分配情况。虚拟内存的一个重要目的就是通过地址转换机制实现程序和操作系统之间的隔离，并且能够提供更高效的内存管理，确保多进程或多任务环境下的安全和稳定。</p> <h3 id="why有虚拟内存"><a href="#why有虚拟内存" class="header-anchor">#</a> Why有虚拟内存</h3> <ul><li><strong>地址冲突</strong>：多个程序可能会尝试访问相同的物理地址，从而引发冲突。虚拟内存可以让每个程序都有自己的独立虚拟地址空间。</li> <li><strong>内存隔离</strong>：虚拟内存使得操作系统能够隔离不同程序的内存空间，提高系统的稳定性和安全性。</li> <li><strong>简化内存管理</strong>：程序员不再需要关心物理内存的管理细节，只需要使用虚拟地址，操作系统会负责将其映射到物理内存中。</li> <li><strong>内存保护</strong>：操作系统可以通过虚拟内存机制来控制程序访问的内存区域，防止程序非法访问内存中的其他部分。
有虚拟内存之后，如何进行管理呢，这就是分段和分页，分段在Linux中作用不明显，先按下不表，我们重点放在分页上。</li></ul> <h3 id="paging"><a href="#paging" class="header-anchor">#</a> Paging</h3> <ul><li>虚拟内存以页(Page)为单位，linux下查看PageSize, <code>getconf PAGE_SIZE</code>，一般为4K，占用12bit</li> <li>物理内存以页帧(Frame)为单位进行管理</li> <li>虚拟地址空间和物理地址空间都按照相同的粒度进行划分，这意味着每个虚拟页都有一个与之对应的物理页帧。在地址转换时，操作系统通过页表来管理和映射虚拟地址和物理地址之间的关系。</li></ul> <h4 id="映射关系存放地-页表"><a href="#映射关系存放地-页表" class="header-anchor">#</a> 映射关系存放地： 页表</h4> <p>因为VA和PA之间无法使用某种映射得来，需要进行动态的管理，页表里面就存储了这种动态关系，页表是操作系统维护，放置在内存中。</p> <h3 id="页表入口"><a href="#页表入口" class="header-anchor">#</a> 页表入口</h3> <ul><li>CR3寄存器也称为PDBR(Page Directory Base Register)，所指向的地址为某个进程的页表的入口，在CPU当前进程发生改变的时候该寄存器中的值会改变,确保每个进程都访问到正确的页表。</li></ul> <h3 id="执行机构-mmu-memory-management-unit-地址管理单元"><a href="#执行机构-mmu-memory-management-unit-地址管理单元" class="header-anchor">#</a> 执行机构: MMU(Memory Management Unit)地址管理单元</h3> <p>MMU是处理虚拟地址到物理地址转换的硬件模块。MMU的基本功能是将虚拟地址（VA）转换为物理地址（PA），从而允许程序访问物理内存。MMU通过页表来完成虚拟地址和物理地址的映射。</p> <ul><li>主要包含两个大模块
<ul><li>TLB(Translation Lookaside Buffer)地址转换后援缓冲器，页表在内存中，为了加速地址转换，将一部分可能用到的表项放入到缓存，其实就是<strong>页表的缓存</strong>。当CPU请求虚拟地址的转换时，首先会查询TLB。如果TLB命中，则直接返回物理地址，避免了频繁访问主存中的页表，从而提高了地址转换的效率。</li> <li>TWU(Table Walk Unit)，当TLB未命中的时候，MMU会通过表步进（Table Walk）方式访问内存中的页表，逐级查找虚拟地址对应的物理地址。这个过程会遍历多个页表级别，直到找到对应的物理页帧。</li></ul></li></ul> <h2 id="执行流程"><a href="#执行流程" class="header-anchor">#</a> 执行流程</h2> <h5 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h5> <ul><li>虚拟页号 VPN(Virtual Page Number)：虚拟地址空间被分为多个虚拟页，每个虚拟页都有一个唯一的虚拟页号（VPN）。虚拟页号是虚拟地址中的一部分，用于在页表中查找映射的物理页号。</li> <li>物理页号 PPN(Physical Page Number) 与 PFN(Page Frame Number): 物理地址空间被划分为多个物理页帧，每个页帧有一个唯一的物理页号（PPN）或页帧号（PFN），这是物理内存中实际存储数据的位置。</li> <li>页表条目PTE(Page Table Entry): 页表条目是页表中的一项，它包含了虚拟页号和物理页号之间的映射关系。每个页表条目指向一个物理页帧（PPN），以及其他一些控制信息，比如访问权限、是否存在等标志。</li> <li>页全局目录 PGD(Page Global Directory)、页上级目录 PUD(Page Upper Directory)、页中间目录 PMD(Page Middle Directory): 这是多级页表的不同层级。每个级别负责将虚拟地址空间划分为不同的区域，每个目录项指向下一层的目录或页表条目，直到最终映射到物理内存页。</li></ul> <h4 id="页表的查询过程"><a href="#页表的查询过程" class="header-anchor">#</a> 页表的查询过程</h4> <ul><li>我们先从只有一层页表来看，过程如下图所示
<img src="/assets/img/l1-pagetable.37eb8949.png" alt="l1-page-table">
在只有一层页表的情况下，虚拟地址被分为两部分：虚拟页号（VPN）和页内偏移量，通过VPN查找页表条目（PTE），该条目指向物理页号（PPN）以及页内的偏移，**物理页号（PPN）**和页内偏移量一起构成物理地址，指向物理内存中的数据。</li> <li>在现代操作系统中，虚拟内存使用多级页表来管理更大的虚拟地址空间。 下图是以x86_64 架构为例，
<img src="/assets/img/l4-pagetable.897c1d19.png" alt="l4-page-table">
从PGD开始，逐级查找每个目录的条目，直到找到最终的页表条目（PTE）。每一级都将虚拟地址的一部分映射到下一层，直到得到物理页号。过页表条目（PTE）中的物理页号（PPN）和页内偏移量，最终得到物理地址。</li></ul> <h4 id="tlb的使用"><a href="#tlb的使用" class="header-anchor">#</a> TLB的使用</h4> <ul><li>TLB缓存的是虚拟页号（VPN）和物理页号（PPN）的映射关系。它不会缓存虚拟地址中的页内偏移部分，因为页内偏移是固定的，在转换时不需要查找。</li> <li>TLB缓存组织方式也是使用组相连或者全相连，如果是组相连，则将VPN再分为Tag和Index部分，这样查找的时候只要使用Index和Tag就能对比是否存在了</li> <li><img src="/assets/img/tlb-use.c71efdab.png" alt="tlb-use">
从图中可以看出，虚拟地址的翻译过程是优先寻找TLB，如果没有找到则找页表，再没有找到触发PageFault到外部存储加载</li> <li>TLB一级缓存一般分为指令和数据两部分，Intel Core i7上提供了二级统一TLB缓存。</li></ul> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>虚拟内存的管理涉及到操作系统和CPU的密切配合。操作系统维护页表并提供虚拟地址到物理地址的映射关系，而CPU通过MMU将虚拟地址转换为物理地址。为了提高效率，CPU使用TLB来加速转换过程，而当TLB未命中时，MMU会通过表步进（Table Walk）查询页表。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/insight/mem-2-cache.html">
        内存和缓存的如何聊天
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.598d8060.js" defer></script><script src="/assets/js/2.4f2e74d3.js" defer></script><script src="/assets/js/12.ebf97c23.js" defer></script>
  </body>
</html>
