# 正则表达式
* Regular Expression
* 不要被"正则"这个专用词影响了理解，这个词只是为了“专用意义”而存在的，其实就是有规律的意思

## 基础
* 形式语言（Formal language）是用精确的数学或机器可处理的公式定义的语言。
* 字符串是字母表中的元素构成的有穷序列
* 所以正则表达式，是对某些字符串进行的筛选，是对语言的另一种组织形式

## PCRE(Perl Compatible RegularExpression)
可以说是正则表达式的老前辈，它是从Perl衍生出来的一个显赫流派，\d \w \s 等表示法就是它的特征；

## BRE(Basic Regular Expression)
POSIX规范的正则表达式之一，grep、vi、sed都属于这一派，它显著的特征就是( ) { } 这几个括号元字符必须经过转义才具有特殊含义，不支持 + ? | 等元字符，随着时间发展，后来又出现了GNU BRE，GNU BRE支持上边这些字符，但是也必须都经过转义才能有特殊含义；

## ERE(Extended Regular Express)
是POSIX规范的正则表达式之一，egrep awk都属于这一派，( ) { }+ ? |等元字符可以直接使用不需要转义，这个流派后来也出现了GNU ERE，在之前的基础上添加了支持\1 \2等。

## 基本规则
* 转义字符也表示一个或者多个字符
* []字符集合中的其中一个, ^[]中表示'非'
* {n,m} 区间个数，闭区间，
* \d(igital) => \D, \w(ord) => \W, \s(pace) => \S, \b => \B   (小写是正常，大写是非)
* ^ $
* + * ? 作用对象是前一个有意义的表达式, + 等于 {1,}, ? 等于{0,1}, * 等于{0,}
* . 通配(除去换行符，换行表示跑路，匹配不了)
* | 或
* [\b] \t \r \n \f \v \0 特殊字符
* ()捕获，意思是将()匹配的结果随着函数返回，捕捉括号后面跟随者\1 \2 \n等奇怪的表达式，组合使用才有疗效
* ()将括号内的表达式做为整体看待
* - 表示按照ascii码连续，0-9,a-z,A-Z，0-@等，0-9 < A-Z < a-z
* x(?=y)if语句的条件不做为匹配的内容
### 总结
* 重复: {} * + ? 
* 或: [] | 
* 所有的规则都可以被展开为字符串的集合
* ^ $ 脑补两个位置
* \w 竟然包括 _  地位如此特殊，仿佛是人类的朋友
* 基本模式/pattern/flags
* \ 功能很强大的符号，将正常人变为不正常，将不正常人变为正常，和not ！ ^ 相似
* 一个匹配规则可以描述为多个等效的表达式
* if 语句，for循环都有
### 解题思路
* 解析表达式：简化分解表达式，就像分析英语的语法
* 合成表达式：逐步递归到复杂阶段
* 有 ^ $ 表示全匹配
### 典型例子
* /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/     密码强度正则，最少 6 位，包括至少 1 个大写字母，1 个小写字母，1 个数字，1 个特殊字符 (包含了5个if条件，wow)
* /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/   URL 正则

## 应用
* sed
```
sed 文本工具支持：BREs、EREs

sed 指令默认是使用"BREs"

sed 命令参数 “-r ” ，则表示要使用“EREs"
```
* grep 
```
grep 支持：BREs、EREs、PREs 正则表达式

grep 指令后不跟任何参数，则表示要使用 ”BREs“ 

grep 指令后跟 ”-E" 参数，则表示要使用 “EREs“

grep 指令后跟 “-P" 参数，则表示要使用 “PREs"
```