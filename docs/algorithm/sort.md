# sort 
## concept
#### 内排序 vs 外排序
* 排序算法的主体为内存，所以使用硬盘的排序为外部排序
#### 时间复杂度
* 在计算机科学中，算法的时间复杂度（Time complexity）是一个函数，它定性描述该算法的运行时间
* 通常使用算法的最坏情况复杂度，记为 T(n) ，定义为任何大小的输入 n 所需的最大运行时间
* 常数阶O(1), 线性阶O(n),对数阶O(logN),线性对数阶O(nlogN),平方阶O(n²),立方阶O(n³)、K次方阶O(n^k),
#### 空间复杂度
* 空间复杂度是对一个算法在运行过程中**临时占用存储空间(主要包括动态分配的空间，以及递归栈所需的空间等，程序本身占用的空间和排序数据占用的数据空间不计)**大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义
* 空间复杂度 O(1)：如果没有申请的空间和递归调用
* 空间复杂度 O(n)
#### 稳定排序
* 排序前后两个相等的数相对位置不变，则算法稳定
#### 原地排序 vs 非原地排序
* 原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。
* 非原地排序需要利用额外的数组来辅助排序
## order 
* numerical order 
* lexicographical order

## 种类
* 冒泡： 最简单直观的一种
* 选择： 一种不可见的冒泡
* 插入：将冒泡反向过程的排序(需要在有序的部分寻找插入的位置)，与快速排序相同之处是**随机找了一个数字**
#### 希尔排序
* 希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n<sup>2</sup>）[二次时间界]的第一批算法之一。
* 希尔排序的增量序列的选择与证明是个数学难题，gap=length/2, 这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为增量序列
* 用逐步逼近的方式排序，类似搜索的思路；使用gap逐渐变小的方式让数组中较大的数值集中在后部，是一种渐进式的排序；而插入、选择、冒泡都可以明确每次的排序结果
* 使用gap将数组切分为N部分，部分内部使用插入排序；最后使用gap=1的实现最后一步的有序
* 最优的区间计算方法是没有答案的，这是一个长期未解决的问题，不过差不多都会取在二分之一到三分之一附近
#### 快速排序(它为什么这么拽，能叫快速排序)
* 快速排序通常写成一个包含 3 个形参的递归函数，这 3 个形参可以定义要排序的数组的一部分，它们分别是，一个包含项目列表的数组 arr，以及两个下标 start 和 end，表示要排序的 arr 数组段的开始和结束。(表示是对数组的某个区段进行排序)
* 例如stl中的sort就是优化的快排
* 最佳实践方案，因为平均性能相当好
* 遍历方法： 单路(算法导论)、双路(谭浩强版)
* 数据移动方法：填坑法、交换法
* 中间值位置: 头部选择，中部选择，尾部选择
* [粗糙的演示](http://htmlpreview.github.io/?https://github.com/angry-sworm/tec-sharing/blob/featrue_sort/docs/sort/animation/index.html)
#### 堆排序(HEAP)<br/>
* 引入了另一种算法设计技术： 领用某种数据结构来管理算法执行中的信息
* 核心算法<br/>![核心算法](./assets/sort/20201029111307.png)

#### 计数排序
* 计数排序只适用于正整数并且取值范围相差不大的数组排序使用
#### 桶排序
* 桶的选择很重要
#### 基数排序
* 证明
```
1. 它们第t位相同，那么此时如果我们保持它们位置的稳定性，那么它们最后仍然有序
2. 它们第t位不同，按照第t位排序之后就有序了
```
* 一种基于权重的比较方式
#### 理解
* 总体是：由一种无序态向有序态转化， 插入排序就是查找有序部分，冒泡、选择则是查找无序部分
* 简单排序的缺点就在于：多了很多没有必要的比较，希尔排序、归并排序、快速排序等都是为了减少这些不必要的比较，所以采用局部有序的方式来进行；因为局部有序之后，只需要one-way合并就可以了，复杂度就是O(n)了
* 在进行分治的时候，使用的区间都是闭区间；切分的时候，不管是奇偶，其实只要能被分为两部分就可以
* 数组比较以某段数据(整体或者局部)作为处理对象，树比较以某个叉树(整体或者局部)做为处理对象
* 计数、基数、桶排序都是类似的排序方法，是基于外部参照物的排序方法(即外部比较)；而比较排序则是基于内部比较的方法
* 大体分为三类：**(1)简单的：冒泡、选择、插入 (2)带有分治的: 希尔、归并、快速 (3)不使用内部比较的: 基数、计数、桶**

## 引用
* [成平动画集锦](https://juejin.im/post/6844903863288332302#heading-9)
* [演示动画合集](https://www.webhek.com/post/comparison-sort.html)
* [一篇打通](https://zhuanlan.zhihu.com/p/57088609)