(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{434:function(t,e,s){t.exports=s.p+"assets/img/20200930211117.fca6d754.png"},435:function(t,e,s){t.exports=s.p+"assets/img/20200930211156.317ec684.png"},436:function(t,e,s){t.exports=s.p+"assets/img/20201012154511.d2597754.png"},437:function(t,e,s){t.exports=s.p+"assets/img/20201012153132.a09d4058.png"},438:function(t,e,s){t.exports=s.p+"assets/img/figure_interruptdispatching_1.8e7878b4.png"},439:function(t,e,s){t.exports=s.p+"assets/img/UDT-03282013.fc35ad43.jpg"},440:function(t,e,s){t.exports=s.p+"assets/img/20200930211027.9d2cb32d.png"},441:function(t,e,s){t.exports=s.p+"assets/img/interrupt_delay_top_bottom.bfdaf305.svg"},442:function(t,e,s){t.exports=s.p+"assets/img/1771657-20200614143709476-1385185613.125b045a.png"},443:function(t,e,s){t.exports=s.p+"assets/img/1771657-20200614144637377-134840993.9c3c34ec.png"},444:function(t,e,s){t.exports=s.p+"assets/img/1771657-20200614144659971-1767445003.cac77544.png"},445:function(t,e,s){t.exports=s.p+"assets/img/20201012165043.209d6612.png"},446:function(t,e,s){t.exports=s.p+"assets/img/20201012165449.99c61e4f.png"},654:function(t,e,s){"use strict";s.r(e);var r=s(26),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"中断"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中断"}},[t._v("#")]),t._v(" 中断")]),t._v(" "),r("ul",[r("li",[t._v("中断是对cpu的劫持")]),t._v(" "),r("li",[t._v("可编程中断的意思是，可以软硬结合")]),t._v(" "),r("li",[t._v("Interrupts and exceptions are events that indicate that a condition exists somewhere in the system, the processor, or within the currently executing program or task that requires the attention of a processor.")]),t._v(" "),r("li",[t._v("System hardware uses interrupts to handle events external to the processor, such as requests to service peripheral devices. Software can also generate interrupts by executing the INT n instruction.")]),t._v(" "),r("li",[t._v("系统调用原来也是中断进入到内核，现在也支持，不过不推荐了")]),t._v(" "),r("li",[t._v("可以认为，除了正常的进程调度，若有其他事件发生，都是通过中断切入到内核的")])]),t._v(" "),r("h2",{attrs:{id:"theory"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#theory"}},[t._v("#")]),t._v(" theory")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("基于event和time的cpu处理模型，time driven & event driven")]),t._v(" "),r("p",[r("img",{attrs:{src:s(434),alt:"event"}})]),t._v(" "),r("hr"),t._v(" "),r("p",[r("img",{attrs:{src:s(435),alt:"event-type"}})])]),t._v(" "),r("li",[r("p",[t._v("signal event interrupt 三种说法")])])]),t._v(" "),r("h2",{attrs:{id:"分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[t._v("#")]),t._v(" 分类")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("同步（synchronous）中断和异步（asynchronous）中断")]),t._v(" "),r("p",[t._v("同步中断是当指令执行时由 CPU 控制单元产生，之所以称为同步，是因为只有在一条指令执行完毕后 CPU 才会发出中断，而不是发生在代码指令执行期间，比如系统调用。")]),t._v(" "),r("p",[t._v("异步中断是指由其他硬件设备依照 CPU 时钟信号随机产生，即意味着中断能够在指令之间发生，例如键盘中断。")])]),t._v(" "),r("li",[r("p",[t._v("根据Intel 官方资料, 同步中断称为异常（exception），异步中断被称为中断（interrupt）")])]),t._v(" "),r("li",[r("p",[t._v("中断可分为可屏蔽中断（Maskable interrupt）和非屏蔽中断（Nomaskable interrupt）")])]),t._v(" "),r("li",[r("p",[t._v("异常可分为故障（fault）、陷阱（trap）、终止（abort）三类 "),r("img",{attrs:{src:s(436),alt:"三者的区别"}})])])]),t._v(" "),r("h2",{attrs:{id:"isr-interrupt-service-routine-实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#isr-interrupt-service-routine-实现"}},[t._v("#")]),t._v(" ISR(Interrupt Service Routine)实现")]),t._v(" "),r("ul",[r("li",[t._v("An interrupt service routine (ISR) is a software routine that hardware invokes in response to an interrupt.")])]),t._v(" "),r("h4",{attrs:{id:"irq-interrupt-request"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#irq-interrupt-request"}},[t._v("#")]),t._v(" IRQ (interrupt request )")]),t._v(" "),r("ul",[r("li",[t._v("an interrupt request (or IRQ) is a "),r("strong",[t._v("hardware signal")]),t._v(" sent to the processor that temporarily stops a running program and allows a special program, an interrupt handler, to run instead.")])]),t._v(" "),r("h4",{attrs:{id:"idt-interrupt-descriptor-table"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#idt-interrupt-descriptor-table"}},[t._v("#")]),t._v(" IDT (Interrupt Descriptor Table)")]),t._v(" "),r("ul",[r("li",[t._v("idt vector definition，使用该vector中的值来索引IDT中的数据\n"),r("img",{attrs:{src:s(437),alt:"idt vector，来自(https://pdos.csail.mit.edu/6.828/2003/readings/intelv3.pdf)"}})])]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("1. The vectors in the range 0 through 31 are reserved by the IA-32 architecture for architecture-defined exceptions and interrupts. Not all of the vectors in this range have a currently defined function. The unassigned vectors in this range are reserved for future uses. Do not use the reserved vectors.\n2. The vectors in the range 32 to 255 are designated as user-defined interrupts and are not reserved by the IA-32 architecture. These interrupts are generally assigned to external I/O devices to enable those devices to send interrupts to the processor through one of the external hardware interrupt mechanisms.\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br")])]),r("ul",[r("li",[r("p",[t._v("一个系统表，它与每一个中断或异常向量相联系，每一个向量在表中存放的是相应的中断或异常处理程序的入口地址。内核在允许中断发生前，也就是在系统初始化时，必须把 IDT 表的初始化地址装载到 idtr 寄存器中，初始化表中的每一项。")]),t._v(" "),r("p",[r("img",{attrs:{src:s(438),alt:"idtr"}})]),t._v(" "),r("hr"),t._v(" "),r("p",[r("img",{attrs:{src:s(439),alt:"idtr&gdt"}})])]),t._v(" "),r("li",[r("p",[t._v("gdt是查看到segment对应的虚拟地址的起始地址")])]),t._v(" "),r("li",[r("p",[t._v("idtr在gdb下无法查看，因为其只有在ring0级别(内核态)才可以看到，而gdb工作在ring3级别(用户态)(intel设计了4层的ring)")])])]),t._v(" "),r("h4",{attrs:{id:"关联的硬件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#关联的硬件"}},[t._v("#")]),t._v(" 关联的硬件")]),t._v(" "),r("ul",[r("li",[t._v("PIC(Programmable Interrupt Controller) & APIC(Advanced Programmable Interrupt Controller)\n"),r("img",{attrs:{src:s(440),alt:"pic"}})]),t._v(" "),r("li",[t._v("local apic，local的参照物为cpu")])]),t._v(" "),r("h4",{attrs:{id:"分为两个阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分为两个阶段"}},[t._v("#")]),t._v(" 分为两个阶段")]),t._v(" "),r("ul",[r("li",[t._v("top half 和 [bottom half](#deferred work )")])]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("上半部(top halves)：不得不做的工作放在上半部，也即中断处理程序中，例如告知外设接收到中断、将数据从外设中拷贝到内存\n下半部(bottom halves)：不紧急的工作延后完成，如处理上半部中从外设拷贝来的数据\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br")])]),r("p",[r("img",{attrs:{src:s(441),alt:"两段"}})]),t._v(" "),r("h2",{attrs:{id:"上下文-context"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#上下文-context"}},[t._v("#")]),t._v(" 上下文(context)")]),t._v(" "),r("h4",{attrs:{id:"中断上下文"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中断上下文"}},[t._v("#")]),t._v(" 中断上下文")]),t._v(" "),r("ul",[r("li",[t._v("每个中断对应一个中断处理函数，当中断处理函数被调用时，内核处于中断上下文(interrupt context)。")]),t._v(" "),r("li",[t._v("不同于进程上下文(process context)，中断处理过程中不能发生阻塞、休眠，即不进行进程调度，因为要快速处理中断的消息以让外设继续工作，另外一个设计上的原因是中断没有独立的堆栈切换机制")]),t._v(" "),r("li",[t._v("中断上下文不执行不属于任何的进程，也可以解释为什么不参与调度")])]),t._v(" "),r("h4",{attrs:{id:"进程上下文"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进程上下文"}},[t._v("#")]),t._v(" 进程上下文")]),t._v(" "),r("ul",[r("li",[t._v("分为用户态(ring3)和内核态(ring0)，两个堆栈可以切换")])]),t._v(" "),r("h2",{attrs:{id:"deferred-work"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#deferred-work"}},[t._v("#")]),t._v(" deferred work")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("三种延迟处理机制，softirq、tasklet、workqueue, tasklets基于softirq")])]),t._v(" "),r("li",[r("p",[t._v("因为硬中断是不可打断的，但是针对网络数据包这种处理阶段比较长的情况，需要只让cpu处理最紧要的事情，其他的事情稍后处理，这就是soft interrup产生的原因")])]),t._v(" "),r("li",[r("p",[t._v("软中断是软件触发的中断，使用raise_softirq接口进行触发，常见的两个触发场景，中断处理后和Bottom-half Enable后")])]),t._v(" "),r("li",[r("p",[t._v("softirq vs tasklet, tasklet提供一种动态的能力")])])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("比对的特点")]),t._v(" "),r("th",[t._v("softirq")]),t._v(" "),r("th",[t._v("tasklet")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("并行能力")]),t._v(" "),r("td",[t._v("同一个softirq处理函数能够同时运行在多个CPU上，因此同步是必要的")]),t._v(" "),r("td",[t._v("同一个tasklet处理函数不能同时运行在多个CPU上，因此同步是不必要的")])]),t._v(" "),r("tr",[r("td",[t._v("中断处理函数的注册方法")]),t._v(" "),r("td",[t._v("只能在编译链接时静态注册")]),t._v(" "),r("td",[t._v("不仅能静态注册而且还能动态注册")])]),t._v(" "),r("tr",[r("td",[t._v("优先级")]),t._v(" "),r("td",[t._v("每个softirq都具有一个执行优先级 ，如果在同一时刻有多个待处理的softirq，那么最高优先级的softirq会被先处理")]),t._v(" "),r("td",[t._v("tasklet只有两种优先级：高优先级「high priority」和正常优先级「normal priority」")])]),t._v(" "),r("tr",[r("td",[t._v("使用场景")]),t._v(" "),r("td",[t._v("仅在执行非常频繁且需要并行处理的场景下才使用")]),t._v(" "),r("td",[t._v("在softirq不能胜任和需要串行化处理的情况下使用，同时在设备驱动中也是可以使用的")])])])]),t._v(" "),r("ul",[r("li",[t._v("softirq类型")])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("0")]),t._v(" "),r("th",[t._v("HI_SOFTIRQ")]),t._v(" "),r("th",[t._v("最高优先级，用于处理TASKLET_HI")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("1")]),t._v(" "),r("td",[t._v("TIMER_SOFTIRQ")]),t._v(" "),r("td",[t._v("用于处理每个CPU的计时器中断「timer interrupt」")])]),t._v(" "),r("tr",[r("td",[t._v("2")]),t._v(" "),r("td",[t._v("NET_TX_SOFTIRQ")]),t._v(" "),r("td",[t._v("用于处理网络设备的报文发送中断")])]),t._v(" "),r("tr",[r("td",[t._v("3")]),t._v(" "),r("td",[t._v("NET_RX_SOFTIRQ")]),t._v(" "),r("td",[t._v("用于处理网络设备的报文接收中断")])]),t._v(" "),r("tr",[r("td",[t._v("4")]),t._v(" "),r("td",[t._v("BLOCK_SOFTIRQ")]),t._v(" "),r("td",[t._v("用于处理块设备「block device」的中断")])]),t._v(" "),r("tr",[r("td",[t._v("5")]),t._v(" "),r("td",[t._v("IRQ_POLL_SOFTIRQ")]),t._v(" "),r("td",[t._v("用于执行IOPOLL的回调函数「handler」")])]),t._v(" "),r("tr",[r("td",[t._v("6")]),t._v(" "),r("td",[t._v("TASKLET_SOFTIRQ")]),t._v(" "),r("td",[t._v("用于处理tasklet")])]),t._v(" "),r("tr",[r("td",[t._v("7")]),t._v(" "),r("td",[t._v("SCHED_SOFTIRQ")]),t._v(" "),r("td",[t._v("用于处理调度「schedule」相关的IPI和执行CFS的负载均衡例程")])]),t._v(" "),r("tr",[r("td",[t._v("8")]),t._v(" "),r("td",[t._v("HRTIMER_SOFTIRQ")]),t._v(" "),r("td",[t._v("目前没有使用，还保留也只是为了占用一个数字")])]),t._v(" "),r("tr",[r("td",[t._v("9")]),t._v(" "),r("td",[t._v("RCU_SOFTIRQ")]),t._v(" "),r("td",[t._v("用于处理RCU中断，最低优先级，因此每次都在最后处理")])])])]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("查看处理数据\n> cat /proc/softirqs \n                    CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7       \n          HI:          1          1          0          0          2          0          0          0\n       TIMER:  241846312 1671934570  273007834 1726792651  201341114 1644008532  182342249 1644896462\n      NET_TX:        138         45        131         71        218         65        122         61\n      NET_RX: 3947735107 3149190903 4033712025 3195028836 3890319448 3119133143 4103968256 3402515225\n       BLOCK:          0          0          0          0          0          0          0          0\nBLOCK_IOPOLL:          0          0          0          0          0          0          0          0\n     TASKLET:        201         29        251         35        188         30        242         35\n       SCHED: 2180338424 3965089846 2186628968 3875527819 2064144853 3883505174 2055440282 3857640088\n     HRTIMER:          0          0          0          0          0          0          0          0\n         RCU: 1458914748 1905483384 1524745564 1923565274 1462350009 1903291217 1446345827 1896192088\n\n查看执行进程\n> ps aux |grep ksoftirqd\nroot          3  0.0  0.0      0     0 ?        S    Sep01   0:22 [ksoftirqd/0]\nroot         14  0.0  0.0      0     0 ?        S    Sep01   2:13 [ksoftirqd/1]\nsandsto+ 111348  0.0  0.0 112816   972 pts/6    S+   21:57   0:00 grep --color=auto ksoftirqd\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br"),r("span",{staticClass:"line-number"},[t._v("8")]),r("br"),r("span",{staticClass:"line-number"},[t._v("9")]),r("br"),r("span",{staticClass:"line-number"},[t._v("10")]),r("br"),r("span",{staticClass:"line-number"},[t._v("11")]),r("br"),r("span",{staticClass:"line-number"},[t._v("12")]),r("br"),r("span",{staticClass:"line-number"},[t._v("13")]),r("br"),r("span",{staticClass:"line-number"},[t._v("14")]),r("br"),r("span",{staticClass:"line-number"},[t._v("15")]),r("br"),r("span",{staticClass:"line-number"},[t._v("16")]),r("br"),r("span",{staticClass:"line-number"},[t._v("17")]),r("br"),r("span",{staticClass:"line-number"},[t._v("18")]),r("br"),r("span",{staticClass:"line-number"},[t._v("19")]),r("br")])]),r("ul",[r("li",[t._v("softirq implement")])]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("/* 支持的软中断类型，可以认为是软中断号， 其中从上到下优先级递减 */\nenum\n{\n\tHI_SOFTIRQ=0,       /* 最高优先级软中断 */\n\tTIMER_SOFTIRQ,      /* Timer定时器软中断 */\n\tNET_TX_SOFTIRQ,     /* 发送网络数据包软中断 */\n\tNET_RX_SOFTIRQ,     /* 接收网络数据包软中断 */\n\tBLOCK_SOFTIRQ,      /* 块设备软中断 */\n\tIRQ_POLL_SOFTIRQ,   /* 块设备软中断 */\n\tTASKLET_SOFTIRQ,    /* tasklet软中断 */\n\tSCHED_SOFTIRQ,      /* 进程调度及负载均衡的软中断 */\n\tHRTIMER_SOFTIRQ, /* Unused, but kept as tools rely on thenumbering. Sigh! */\n\tRCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq， RCU相关的软中断 */\n\n\tNR_SOFTIRQS\n};\n\n/* 软件中断描述符，只包含一个handler函数指针 */\nstruct softirq_action {\n\tvoid\t(*action)(struct softirq_action *);\n};\n/* 软中断描述符表，实际上就是一个全局的数组 */\nstatic struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;\n\n/* CPU软中断状态描述，当某个软中断触发时，__softirq_pending会置位对应的bit */\ntypedef struct {\n\tunsigned int __softirq_pending;\n\tunsigned int ipi_irqs[NR_IPI];\n} ____cacheline_aligned irq_cpustat_t;\n/* 每个CPU都会维护一个状态信息结构 */\nirq_cpustat_t irq_stat[NR_CPUS] ____cacheline_aligned;\n\n/* 内核为每个CPU都创建了一个软中断处理内核线程 */\nDEFINE_PER_CPU(struct task_struct *, ksoftirqd);\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br"),r("span",{staticClass:"line-number"},[t._v("8")]),r("br"),r("span",{staticClass:"line-number"},[t._v("9")]),r("br"),r("span",{staticClass:"line-number"},[t._v("10")]),r("br"),r("span",{staticClass:"line-number"},[t._v("11")]),r("br"),r("span",{staticClass:"line-number"},[t._v("12")]),r("br"),r("span",{staticClass:"line-number"},[t._v("13")]),r("br"),r("span",{staticClass:"line-number"},[t._v("14")]),r("br"),r("span",{staticClass:"line-number"},[t._v("15")]),r("br"),r("span",{staticClass:"line-number"},[t._v("16")]),r("br"),r("span",{staticClass:"line-number"},[t._v("17")]),r("br"),r("span",{staticClass:"line-number"},[t._v("18")]),r("br"),r("span",{staticClass:"line-number"},[t._v("19")]),r("br"),r("span",{staticClass:"line-number"},[t._v("20")]),r("br"),r("span",{staticClass:"line-number"},[t._v("21")]),r("br"),r("span",{staticClass:"line-number"},[t._v("22")]),r("br"),r("span",{staticClass:"line-number"},[t._v("23")]),r("br"),r("span",{staticClass:"line-number"},[t._v("24")]),r("br"),r("span",{staticClass:"line-number"},[t._v("25")]),r("br"),r("span",{staticClass:"line-number"},[t._v("26")]),r("br"),r("span",{staticClass:"line-number"},[t._v("27")]),r("br"),r("span",{staticClass:"line-number"},[t._v("28")]),r("br"),r("span",{staticClass:"line-number"},[t._v("29")]),r("br"),r("span",{staticClass:"line-number"},[t._v("30")]),r("br"),r("span",{staticClass:"line-number"},[t._v("31")]),r("br"),r("span",{staticClass:"line-number"},[t._v("32")]),r("br"),r("span",{staticClass:"line-number"},[t._v("33")]),r("br"),r("span",{staticClass:"line-number"},[t._v("34")]),r("br")])]),r("hr"),t._v(" "),r("p",[r("img",{attrs:{src:s(442),alt:"softirq-struct"}})]),t._v(" "),r("ul",[r("li",[t._v("tasklet的实现图解")])]),t._v(" "),r("p",[r("img",{attrs:{src:s(443),alt:"tasklet frame"}})]),t._v(" "),r("hr"),t._v(" "),r("p",[r("img",{attrs:{src:s(444),alt:"tasklet process"}}),t._v("\n注意tasklet_action是和softirq的关联点")]),t._v(" "),r("h2",{attrs:{id:"查看中断在cpu上的执行情况"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#查看中断在cpu上的执行情况"}},[t._v("#")]),t._v(" 查看中断在cpu上的执行情况")]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v(" cat /proc/interrupts \n            CPU0       CPU1       \n   0:         90          0   IO-APIC-edge      timer\n   1:         12          0   IO-APIC-edge      i8042\n   6:         17          0   IO-APIC-edge      floppy\n   8:          1          0   IO-APIC-edge      rtc0\n   9:          0          0   IO-APIC-fasteoi   acpi\n  12:         58          0   IO-APIC-edge      i8042\n  14:          0          0   IO-APIC-edge      ata_piix\n  15:    2502351          0   IO-APIC-edge      ata_piix\n  16:          2          0   IO-APIC-fasteoi   vmwgfx, snd_ens1371\n  17:    2997408          0   IO-APIC-fasteoi   ehci_hcd:usb1, ioc0\n  18:         71          0   IO-APIC-fasteoi   uhci_hcd:usb2\n  19:        145  111310754   IO-APIC-fasteoi   ens33\n  24:          0          0   PCI-MSI-edge      PCIe PME, pciehp\n  25:          0          0   PCI-MSI-edge      PCIe PME, pciehp\n  26:          0          0   PCI-MSI-edge      PCIe PME, pciehp\n  ...\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br"),r("span",{staticClass:"line-number"},[t._v("8")]),r("br"),r("span",{staticClass:"line-number"},[t._v("9")]),r("br"),r("span",{staticClass:"line-number"},[t._v("10")]),r("br"),r("span",{staticClass:"line-number"},[t._v("11")]),r("br"),r("span",{staticClass:"line-number"},[t._v("12")]),r("br"),r("span",{staticClass:"line-number"},[t._v("13")]),r("br"),r("span",{staticClass:"line-number"},[t._v("14")]),r("br"),r("span",{staticClass:"line-number"},[t._v("15")]),r("br"),r("span",{staticClass:"line-number"},[t._v("16")]),r("br"),r("span",{staticClass:"line-number"},[t._v("17")]),r("br"),r("span",{staticClass:"line-number"},[t._v("18")]),r("br")])]),r("h2",{attrs:{id:"中断的返回"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#中断的返回"}},[t._v("#")]),t._v(" 中断的返回")]),t._v(" "),r("ul",[r("li",[t._v("When the processor performs a call to the exception- or interrupt-handler procedure, it saves the current states of the EFLAGS register, CS register, and EIP register on the stack. (The CS and EIP registers provide a return instruction pointer for the handler.) If an exception causes an error code to be saved, it is pushed on the stack after the EIP value.")]),t._v(" "),r("li",[t._v("If the handler procedure is going to be executed at the same privilege level as the interrupted procedure, the handler uses the current stack.")]),t._v(" "),r("li",[t._v("If the handler procedure is going to be executed at a numerically lower privilege level, a stack switch occurs. When a stack switch occurs, a stack pointer for the stack to be returned to is also saved on the stack. (The SS and ESP registers provide a return stack pointer for the handler.) The segment selector and stack pointer for the stack to be used by the handler is obtained from the TSS for the currently executing task. The processor copies the EFLAGS, SS, ESP, CS, EIP, and error code information from the interrupted procedure’s stack to the handler’s stack.")]),t._v(" "),r("li",[t._v("If a stack switch occurred when calling the handler procedure, the IRET instruction switches back to the interrupted procedure’s stack on the return.\n"),r("img",{attrs:{src:s(445),alt:"stack of interrupt"}})])]),t._v(" "),r("p",[r("img",{attrs:{src:s(446),alt:"return"}})]),t._v(" "),r("h2",{attrs:{id:"signal"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#signal"}},[t._v("#")]),t._v(" signal")]),t._v(" "),r("ul",[r("li",[t._v("就是计算机内部通信的基本机制，不管是进程间还是硬件与cpu之间")])]),t._v(" "),r("h2",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),r("p",[r("a",{attrs:{href:"http://arthurchiao.art/blog/system-call-definitive-guide-zh/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Linux 系统调用权威指南"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://pdos.csail.mit.edu/6.828/2003/readings/intelv3.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("IA-32 Intel开发者手册"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://pdos.csail.mit.edu/6.828/2004/lec/lec8-slides.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Interrupt and Exception Handling on the x86"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=a.exports}}]);