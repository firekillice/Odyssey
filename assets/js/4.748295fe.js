(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{450:function(t,_,r){t.exports=r.p+"assets/img/bst-simple-01.7c38ee70.png"},451:function(t,_,r){t.exports=r.p+"assets/img/bst-simple-search.9aa0f0aa.png"},452:function(t,_,r){t.exports=r.p+"assets/img/bst-simple-insert.a2715ad9.png"},453:function(t,_,r){t.exports=r.p+"assets/img/bst-simple-delete.7a5c6ddd.png"},454:function(t,_,r){t.exports=r.p+"assets/img/AVL_LL_Rotation_SmoothLine_ManimCE_v0.19.0.f2928173.gif"},455:function(t,_,r){t.exports=r.p+"assets/img/AVL_RR_Rotation_Correct_ManimCE_v0.19.0.9da55cdb.gif"},456:function(t,_,r){t.exports=r.p+"assets/img/AVL_LR_Rotation_Final_ManimCE_v0.19.0.04dfecc3.gif"},457:function(t,_,r){t.exports=r.p+"assets/img/AVL_RL_Rotation_ManimCE_v0.19.0.2ccf3148.gif"},458:function(t,_,r){t.exports=r.p+"assets/img/rb-add-red-red.93f8601a.gif"},459:function(t,_,r){t.exports=r.p+"assets/img/RBTreeInsertLLCorrect_ManimCE_v0.19.0.3dbbd855.gif"},460:function(t,_,r){t.exports=r.p+"assets/img/RBTreeInsertRRCorrect_ManimCE_v0.19.0.c77e8179.gif"},461:function(t,_,r){t.exports=r.p+"assets/img/RBTreeInsertLRCorrect_ManimCE_v0.19.0.7aada939.gif"},462:function(t,_,r){t.exports=r.p+"assets/img/RBTreeInsertRLCorrect_ManimCE_v0.19.0.19d237d7.gif"},463:function(t,_,r){t.exports=r.p+"assets/img/RBTreeDeleteRightNilBrotherLeftRed_ManimCE_v0.19.0.ddcf3b3f.gif"},464:function(t,_,r){t.exports=r.p+"assets/img/RBTreeDeleteRightNilBrotherRightRed_ManimCE_v0.19.0.223da06b.gif"},465:function(t,_,r){t.exports=r.p+"assets/img/RBTreeDeleteLeftNilBrotherRightRed_ManimCE_v0.19.0.e5f40fb9.gif"},466:function(t,_,r){t.exports=r.p+"assets/img/RBTreeDeleteLeftNilBrotherRightLeftRedRL_ManimCE_v0.19.0.214f1da3.gif"},467:function(t,_,r){t.exports=r.p+"assets/img/RBTreeDeleteRightNilBrotherRed_ManimCE_v0.19.0.de429bd5.gif"},468:function(t,_,r){t.exports=r.p+"assets/img/RBTreeDeleteLeftNilBrotherRed_ManimCE_v0.19.0.7f25fd25.gif"},567:function(t,_,r){"use strict";r.r(_);var a=r(36),v=Object(a.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_1-bst-binary-search-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-bst-binary-search-tree"}},[t._v("#")]),t._v(" 1. BST (Binary Search Tree)")]),t._v(" "),a("ul",[a("li",[t._v("二叉搜索树，顾名思义，它是一种二叉树，并且可以用来进行搜索")])]),t._v(" "),a("h2",{attrs:{id:"_1-1-特征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-特征"}},[t._v("#")]),t._v(" 1.1 特征")]),t._v(" "),a("ol",[a("li",[t._v("对于根节点，左子树中所有节点的值 < 根节点的值 < 右子树中所有节点的值")]),t._v(" "),a("li",[t._v("任意节点的左、右子树也是二叉搜索树，即同样满足条件"),a("strong",[t._v("1")])])]),t._v(" "),a("h2",{attrs:{id:"_1-2-举例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-举例"}},[t._v("#")]),t._v(" 1.2 举例")]),t._v(" "),a("ul",[a("li",[a("img",{attrs:{src:r(450),alt:"bst-simple-001"}})])]),t._v(" "),a("h2",{attrs:{id:"_1-3-查找"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-查找"}},[t._v("#")]),t._v(" 1.3 查找")]),t._v(" "),a("ul",[a("li",[a("img",{attrs:{src:r(451),alt:"bst-simple-search"}})])]),t._v(" "),a("h2",{attrs:{id:"_1-4-插入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-插入"}},[t._v("#")]),t._v(" 1.4 插入")]),t._v(" "),a("ul",[a("li",[a("img",{attrs:{src:r(452),alt:"bst-simple-insert"}})])]),t._v(" "),a("h2",{attrs:{id:"_1-5-删除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-删除"}},[t._v("#")]),t._v(" 1.5 删除")]),t._v(" "),a("p",[a("img",{attrs:{src:r(453),alt:"bst-simple-delete"}})]),t._v(" "),a("h2",{attrs:{id:"_2-平衡二叉树、avl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-平衡二叉树、avl"}},[t._v("#")]),t._v(" 2. 平衡二叉树、AVL")]),t._v(" "),a("ul",[a("li",[t._v("AVL是平衡二叉树的一种，是一种高度平衡的二叉树，是最早被发明的平衡二叉树")]),t._v(" "),a("li",[t._v("还有Splay Tree、Treap等")]),t._v(" "),a("li",[t._v("大学教授 G.M. Adelson-Velsky 和 E.M. Landis 名称的缩写，他们提出的平衡二叉树的概念，为了纪念他们，将平衡二叉树称为 AVL树。")])]),t._v(" "),a("h2",{attrs:{id:"_2-1-特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-特点"}},[t._v("#")]),t._v(" 2.1 特点")]),t._v(" "),a("ul",[a("li",[t._v("要么是空树")]),t._v(" "),a("li",[t._v("要么左右子树的高度之差的绝对值不超过1")])]),t._v(" "),a("h2",{attrs:{id:"_2-2-平衡因子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-平衡因子"}},[t._v("#")]),t._v(" 2.2 平衡因子")]),t._v(" "),a("ul",[a("li",[t._v("左子树的高度减去右子树的高度，空节点的平衡因子为0")]),t._v(" "),a("li",[t._v("1、0、-1都认为是平衡的")])]),t._v(" "),a("h2",{attrs:{id:"_2-3-旋转"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-旋转"}},[t._v("#")]),t._v(" 2.3 旋转")]),t._v(" "),a("p",[t._v("为了维持树的平衡，最重要的操作是对树进行"),a("strong",[t._v("旋转")]),t._v("操作，旋转后保持有序和平衡。根据树的形状的不同分为左旋、右旋、先左旋再右旋、先右旋再左旋，下面我们依次进行讨论")]),t._v(" "),a("h2",{attrs:{id:"_2-3-1-ll型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-ll型"}},[t._v("#")]),t._v(" 2.3.1 LL型")]),t._v(" "),a("p",[a("img",{attrs:{src:r(454),alt:"avl-ll"}})]),t._v(" "),a("h2",{attrs:{id:"_2-3-2-rr型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-rr型"}},[t._v("#")]),t._v(" 2.3.2 RR型")]),t._v(" "),a("p",[a("img",{attrs:{src:r(455),alt:"avl-rr"}})]),t._v(" "),a("h2",{attrs:{id:"_2-3-3-lr型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-3-lr型"}},[t._v("#")]),t._v(" 2.3.3 LR型")]),t._v(" "),a("p",[a("img",{attrs:{src:r(456),alt:"avl-lr"}})]),t._v(" "),a("h2",{attrs:{id:"_2-3-4-rl型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-4-rl型"}},[t._v("#")]),t._v(" 2.3.4 RL型")]),t._v(" "),a("p",[a("img",{attrs:{src:r(457),alt:"avl-rl"}})]),t._v(" "),a("h2",{attrs:{id:"_2-4-分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-分析"}},[t._v("#")]),t._v(" 2.4 分析")]),t._v(" "),a("ul",[a("li",[t._v("旋转的核心就是将"),a("strong",[t._v("中间值")]),t._v("放在合适的父节点上，上述的例子就是将6放在父节点上。")]),t._v(" "),a("li",[t._v("LR型是先转为LL型，将数字6放在中间位置")]),t._v(" "),a("li",[t._v("RL型是先转为RR型，将数字6放在中间位置")]),t._v(" "),a("li",[t._v("RR型和LL型的可视化顺序和大小顺序是一致的，可以直接进行旋转")])]),t._v(" "),a("h2",{attrs:{id:"_3-红黑树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-红黑树"}},[t._v("#")]),t._v(" 3. 红黑树")]),t._v(" "),a("ul",[a("li",[t._v("继承于二叉搜索树")]),t._v(" "),a("li",[t._v("红黑树是一种不大严格的平衡树(AVL树为了平衡做了太多的旋转)")])]),t._v(" "),a("h2",{attrs:{id:"_3-1-特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-特点"}},[t._v("#")]),t._v(" 3.1 特点")]),t._v(" "),a("ol",[a("li",[t._v("每个节点非红即黑")]),t._v(" "),a("li",[t._v("根节点是黑的")]),t._v(" "),a("li",[t._v("NIL节点(空叶子节点)为黑色")]),t._v(" "),a("li",[t._v("红色节点的子节点为黑色")]),t._v(" "),a("li",[t._v("对于任意节点而言,其到叶子点树NIL指针的每条路径都包含相同数目的黑节点.")])]),t._v(" "),a("h2",{attrs:{id:"_3-1-1-理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-理解"}},[t._v("#")]),t._v(" 3.1.1 理解")]),t._v(" "),a("ul",[a("li",[t._v("红红不能相邻，黑黑可以相邻")]),t._v(" "),a("li",[t._v("有一个不可见的虚拟空节点，颜色为黑，在统计"),a("code",[t._v("特点5")]),t._v("的时候需要考虑在内")]),t._v(" "),a("li",[t._v("新节点默认是红色，如果是黑色，就会影响到"),a("code",[t._v("特点5")])]),t._v(" "),a("li",[t._v("最短路径一定是：全部都是黑色；最长路径为红黑相间")])]),t._v(" "),a("h2",{attrs:{id:"_3-1-2-术语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-术语"}},[t._v("#")]),t._v(" 3.1.2 术语")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("黑黑：两个相邻的黑色节点")])]),t._v(" "),a("li",[a("p",[t._v("红红：两个相邻的红色节点(实际上不会出现)")])]),t._v(" "),a("li",[a("p",[t._v("黑高：节点到叶子节点路途中黑色节点的个数")]),t._v(" "),a("p",[t._v("添加节点相对比较简单，我们先说添加节点，再说删除节点。")])])]),t._v(" "),a("h2",{attrs:{id:"_3-3-添加节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-添加节点"}},[t._v("#")]),t._v(" 3.3 添加节点")]),t._v(" "),a("ul",[a("li",[t._v("如果是根结点，则为黑色，其他节点默认为红色")]),t._v(" "),a("li",[t._v("如果父节点为黑色，则直接插入即可")]),t._v(" "),a("li",[t._v("如果父节点为红色，则分为以下两种情况")])]),t._v(" "),a("h2",{attrs:{id:"_3-3-1-父节点为红-叔节点为红色"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-父节点为红-叔节点为红色"}},[t._v("#")]),t._v(" 3.3.1 父节点为红，叔节点为红色")]),t._v(" "),a("ul",[a("li",[t._v("因为红色节点的子节点为黑，所以祖先节点一定是黑色节点")]),t._v(" "),a("li",[t._v("因为插入的新节点为红色，出现了非法的红红，这个时候将祖先节点标记为红，父节点和叔节点标记为黑")]),t._v(" "),a("li",[t._v("结果就是"),a("strong",[t._v("增加了一个黑高")]),t._v("，导致黑高不一致，将祖先节点作为当前节点"),a("strong",[t._v("沿路径向上进行递归调整")])]),t._v(" "),a("li",[a("img",{attrs:{src:r(458),alt:"rb-add-red-red"}})])]),t._v(" "),a("h2",{attrs:{id:"_3-3-2-父节点为红-叔节点为黑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-父节点为红-叔节点为黑"}},[t._v("#")]),t._v(" 3.3.2 父节点为红，叔节点为黑")]),t._v(" "),a("ul",[a("li",[t._v("按照LL、LR、RR、RL等四种类型进行旋转，LR转换为LL，RL转换为RR，最终的形状为LL或者RR")]),t._v(" "),a("li",[t._v("父节点变黑，父节点的父节点变红，然后对LL右旋或者对RR左旋后")]),t._v(" "),a("li",[t._v("最终结果是：将相邻的两个红色节点拆开到另一侧，"),a("strong",[t._v("两侧都维持黑高不变，不需要递归")])]),t._v(" "),a("li",[t._v("LL"),a("br"),t._v(" "),a("img",{attrs:{src:r(459),alt:"rotate-ll"}})]),t._v(" "),a("li",[t._v("RR"),a("br"),t._v(" "),a("img",{attrs:{src:r(460),alt:"rotate-rr"}})]),t._v(" "),a("li",[t._v("LR"),a("br"),t._v(" "),a("img",{attrs:{src:r(461),alt:"rotate-lr"}})]),t._v(" "),a("li",[t._v("RL"),a("br"),t._v(" "),a("img",{attrs:{src:r(462),alt:"rotate-rl"}})])]),t._v(" "),a("h2",{attrs:{id:"_3-2-删除节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-删除节点"}},[t._v("#")]),t._v(" 3.2 删除节点")]),t._v(" "),a("ul",[a("li",[t._v("删除节点的时候如果是叶子节点就执行删除操作，否则需要寻找临近节点替换后再进行删除操作")]),t._v(" "),a("li",[t._v("删除过程中涉及到向上追溯，需要使用栈来记录最终删除节点的路径")])]),t._v(" "),a("h2",{attrs:{id:"_3-2-1-目标节点为红色"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-目标节点为红色"}},[t._v("#")]),t._v(" 3.2.1 目标节点为红色")]),t._v(" "),a("ul",[a("li",[t._v("直接删除即可")]),t._v(" "),a("li",[t._v("因为红色节点一定是空节点\n"),a("ul",[a("li",[t._v("首先它不可能是有红色子节点，红红不能相邻")]),t._v(" "),a("li",[t._v("因为最多有一边有子节点（否则就要继续查找），所以它一定没有黑色子节点，否则两侧的黑高不相同")])])])]),t._v(" "),a("h2",{attrs:{id:"_3-2-2-目标节点为黑色且有孩子节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-目标节点为黑色且有孩子节点"}},[t._v("#")]),t._v(" 3.2.2 目标节点为黑色且有孩子节点")]),t._v(" "),a("ul",[a("li",[t._v("子节点一定是红色，否则两侧的黑高不相同")]),t._v(" "),a("li",[t._v("将目标节点删除后，将子节点向上移动，然后改颜色为黑，保持黑高稳定")])]),t._v(" "),a("h2",{attrs:{id:"_3-2-3-目标节点为黑色且有无孩子节点-这个最麻烦"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3-目标节点为黑色且有无孩子节点-这个最麻烦"}},[t._v("#")]),t._v(" 3.2.3 目标节点为黑色且有无孩子节点(这个最麻烦)")]),t._v(" "),a("ul",[a("li",[t._v("这种情况下，一定有兄弟节点，否则父节点的两侧两侧黑高不相同")]),t._v(" "),a("li",[t._v("之所以考虑兄弟节点，是为了最低成本的保持两侧黑高相同，减少递归次数")])]),t._v(" "),a("h2",{attrs:{id:"_3-2-3-1-兄弟节点为黑色"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3-1-兄弟节点为黑色"}},[t._v("#")]),t._v(" 3.2.3.1 兄弟节点为黑色")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("目标节点是其父节点的右节点，兄弟节点的左节点为红色")]),t._v(" "),a("ul",[a("li",[t._v("属于LL型, 执行右旋，最后直接删除节点")]),t._v(" "),a("li",[t._v("兄弟节点的左节点变黑，维持兄弟节点的黑高")]),t._v(" "),a("li",[t._v("兄弟节点成为父节点，颜色设置为原父亲节点的颜色")]),t._v(" "),a("li",[t._v("原父节点设置为黑色，保持右侧的黑高不变")]),t._v(" "),a("li",[a("img",{attrs:{src:r(463),alt:"rb-delete-left-brother-black-and-brother-left-red"}})])])]),t._v(" "),a("li",[a("p",[t._v("目标节点是其父节点的右节点，兄弟节点的右节点为红色")]),t._v(" "),a("ul",[a("li",[t._v("属于LR型，需要调整为LL型，然后右旋,最后直接删除节点")]),t._v(" "),a("li",[t._v("兄弟节点的右节点颜色转为父节点的颜色(因为最终它会变为父节点)")]),t._v(" "),a("li",[t._v("父节点的颜色变为黑色，因为它会被旋转到右侧，来维持右侧的黑高不变")]),t._v(" "),a("li",[a("img",{attrs:{src:r(464),alt:"rb-delete-left-brother-black-and-brother-right-red"}})])])]),t._v(" "),a("li",[a("p",[t._v("目标节点是其父节点的右节点,兄弟节点无子节点(兄弟节点一定为黑)")]),t._v(" "),a("ul",[a("li",[t._v("将兄弟节点设置为红色，即两侧都同时减去一个黑色节点")]),t._v(" "),a("li",[t._v("如果其父节点刚好为红色，可以立即变黑，保持黑高不变，就可以返回")]),t._v(" "),a("li",[t._v("但是如果父节点刚好黑色，将目标节点删除后"),a("strong",[t._v("向上递归")]),t._v("，将"),a("strong",[t._v("父节点转为目标节点")]),t._v("进行调整符合红黑树规则")])])]),t._v(" "),a("li",[a("p",[t._v("目标节点是其父节点的左节点,兄弟节点的右节点为红色")]),t._v(" "),a("ul",[a("li",[t._v("属于RR型，执行左旋，最后直接删除目标节点")]),t._v(" "),a("li",[t._v("兄弟节点的右节点变黑，维持兄弟节点的黑高")]),t._v(" "),a("li",[t._v("兄弟节点成为父节点，颜色设置为原父亲节点的颜色")]),t._v(" "),a("li",[t._v("原父节点设置为黑色，保持右侧的黑高不变")]),t._v(" "),a("li",[a("img",{attrs:{src:r(465),alt:"rb-delete-right-brother-black-and-brother-right-red"}})])])]),t._v(" "),a("li",[a("p",[t._v("目标节点是其父节点的左节点,兄弟节点的左节点为红色")]),t._v(" "),a("ul",[a("li",[t._v("属于RL型，调整为RR型，然后左旋,最后直接删除节点")]),t._v(" "),a("li",[t._v("兄弟节点的左节点颜色转为父节点的颜色(因为最终它会变为父节点)")]),t._v(" "),a("li",[t._v("父节点的颜色变为黑色，因为它会被旋转到右侧，来维持右侧的黑高不变")]),t._v(" "),a("li",[a("img",{attrs:{src:r(466),alt:"rb-delete-right-brother-black-and-brother-left-red"}})])])]),t._v(" "),a("li",[a("p",[t._v("目标节点是其父节点的左节点,兄弟节点无子节点(兄弟节点一定为黑)")]),t._v(" "),a("ul",[a("li",[t._v("将兄弟节点设置为红色，即两侧都同时减去一个黑色节点")]),t._v(" "),a("li",[t._v("如果其父节点刚好为红色，可以立即变黑，保持黑高不变，就可以返回")]),t._v(" "),a("li",[t._v("但是如果父节点刚好黑色，将目标节点删除后"),a("strong",[t._v("向上递归")]),t._v("，将"),a("strong",[t._v("父节点转为目标节点")]),t._v("进行调整符合红黑树规则")])])])]),t._v(" "),a("h2",{attrs:{id:"_3-2-3-2-兄弟节点为红色"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3-2-兄弟节点为红色"}},[t._v("#")]),t._v(" 3.2.3.2 兄弟节点为红色")]),t._v(" "),a("ul",[a("li",[t._v("这种情形不能直接进行处理，需要转换形态")])]),t._v(" "),a("ol",[a("li",[t._v("目标节点是其父节点的左节点\n"),a("ul",[a("li",[t._v("兄弟节点与父节点互换颜色，即兄弟变为黑色，父亲变为红色")]),t._v(" "),a("li",[t._v("执行左旋")]),t._v(" "),a("li",[t._v("如图所示，旋转后黑高保持不变，继续对"),a("strong",[t._v("D")]),t._v("执行删除操作")]),t._v(" "),a("li",[a("img",{attrs:{src:r(467),alt:"rb-delete-left-brother-red"}})])])]),t._v(" "),a("li",[t._v("目标节点是其父节点的右节点\n"),a("ul",[a("li",[t._v("兄弟节点与父节点互换颜色，即兄弟变为黑色，父亲变为红色")]),t._v(" "),a("li",[t._v("执行右旋")]),t._v(" "),a("li",[t._v("如图所示，旋转后黑高保持不变，继续对"),a("strong",[t._v("D")]),t._v("执行删除操作")]),t._v(" "),a("li",[a("img",{attrs:{src:r(468),alt:"rb-delete-right-brother-red"}})])])])]),t._v(" "),a("h2",{attrs:{id:"引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[t._v("#")]),t._v(" 引用")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://oi-wiki.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("oi-wiki"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.cs.usfca.edu/~galles/visualization/RedBlack.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("rb-animation"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=v.exports}}]);