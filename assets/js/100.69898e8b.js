(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{698:function(s,a,e){"use strict";e.r(a);var r=e(26),v=Object(r.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"正则表达式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[s._v("#")]),s._v(" 正则表达式")]),s._v(" "),e("ul",[e("li",[s._v("Regular Expression")]),s._v(" "),e("li",[s._v('不要被"正则"这个专用词影响了理解，这个词只是为了“专用意义”而存在的，其实就是有规律的意思')])]),s._v(" "),e("h2",{attrs:{id:"基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[s._v("#")]),s._v(" 基础")]),s._v(" "),e("ul",[e("li",[s._v("形式语言（Formal language）是用精确的数学或机器可处理的公式定义的语言。")]),s._v(" "),e("li",[s._v("字符串是字母表中的元素构成的有穷序列")]),s._v(" "),e("li",[s._v("所以正则表达式，是对某些字符串进行的筛选，是对语言的另一种组织形式")])]),s._v(" "),e("h2",{attrs:{id:"pcre-perl-compatible-regularexpression"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pcre-perl-compatible-regularexpression"}},[s._v("#")]),s._v(" PCRE(Perl Compatible RegularExpression)")]),s._v(" "),e("p",[s._v("可以说是正则表达式的老前辈，它是从Perl衍生出来的一个显赫流派，\\d \\w \\s 等表示法就是它的特征；")]),s._v(" "),e("h2",{attrs:{id:"bre-basic-regular-expression"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bre-basic-regular-expression"}},[s._v("#")]),s._v(" BRE(Basic Regular Expression)")]),s._v(" "),e("p",[s._v("POSIX规范的正则表达式之一，grep、vi、sed都属于这一派，它显著的特征就是( ) { } 这几个括号元字符必须经过转义才具有特殊含义，不支持 + ? | 等元字符，随着时间发展，后来又出现了GNU BRE，GNU BRE支持上边这些字符，但是也必须都经过转义才能有特殊含义；")]),s._v(" "),e("h2",{attrs:{id:"ere-extended-regular-express"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ere-extended-regular-express"}},[s._v("#")]),s._v(" ERE(Extended Regular Express)")]),s._v(" "),e("p",[s._v("是POSIX规范的正则表达式之一，egrep awk都属于这一派，( ) { }+ ? |等元字符可以直接使用不需要转义，这个流派后来也出现了GNU ERE，在之前的基础上添加了支持\\1 \\2等。")]),s._v(" "),e("h2",{attrs:{id:"基本规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本规则"}},[s._v("#")]),s._v(" 基本规则")]),s._v(" "),e("ul",[e("li",[s._v("转义字符也表示一个或者多个字符")]),s._v(" "),e("li",[s._v("[]字符集合中的其中一个, ^[]中表示'非'")]),s._v(" "),e("li",[s._v("{n,m} 区间个数，闭区间，")]),s._v(" "),e("li",[s._v("\\d(igital) => \\D, \\w(ord) => \\W, \\s(pace) => \\S, \\b => \\B   (小写是正常，大写是非)")]),s._v(" "),e("li",[s._v("^ $")]),s._v(" "),e("li",[e("ul",[e("li",[e("ul",[e("li",[s._v("? 作用对象是前一个有意义的表达式, + 等于 {1,}, ? 等于{0,1}, * 等于{0,}")])])])])]),s._v(" "),e("li",[s._v(". 通配(除去换行符，换行表示跑路，匹配不了)")]),s._v(" "),e("li",[s._v("| 或")]),s._v(" "),e("li",[s._v("[\\b] \\t \\r \\n \\f \\v \\0 特殊字符")]),s._v(" "),e("li",[s._v("()捕获，意思是将()匹配的结果随着函数返回，捕捉括号后面跟随者\\1 \\2 \\n等奇怪的表达式，组合使用才有疗效")]),s._v(" "),e("li",[s._v("()将括号内的表达式做为整体看待")]),s._v(" "),e("li",[e("ul",[e("li",[s._v("表示按照ascii码连续，0-9,a-z,A-Z，0-@等，0-9 < A-Z < a-z")])])]),s._v(" "),e("li",[s._v("x(?=y)if语句的条件不做为匹配的内容")])]),s._v(" "),e("h3",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),e("ul",[e("li",[s._v("重复: {} * + ?")]),s._v(" "),e("li",[s._v("或: [] |")]),s._v(" "),e("li",[s._v("所有的规则都可以被展开为字符串的集合")]),s._v(" "),e("li",[s._v("^ $ 脑补两个位置")]),s._v(" "),e("li",[s._v("\\w 竟然包括 _  地位如此特殊，仿佛是人类的朋友")]),s._v(" "),e("li",[s._v("基本模式/pattern/flags")]),s._v(" "),e("li",[s._v("\\ 功能很强大的符号，将正常人变为不正常，将不正常人变为正常，和not ！ ^ 相似")]),s._v(" "),e("li",[s._v("一个匹配规则可以描述为多个等效的表达式")]),s._v(" "),e("li",[s._v("if 语句，for循环都有")])]),s._v(" "),e("h3",{attrs:{id:"解题思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[s._v("#")]),s._v(" 解题思路")]),s._v(" "),e("ul",[e("li",[s._v("解析表达式：简化分解表达式，就像分析英语的语法")]),s._v(" "),e("li",[s._v("合成表达式：逐步递归到复杂阶段")]),s._v(" "),e("li",[s._v("有 ^ $ 表示全匹配")])]),s._v(" "),e("h3",{attrs:{id:"典型例子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#典型例子"}},[s._v("#")]),s._v(" 典型例子")]),s._v(" "),e("ul",[e("li",[s._v("/^."),e("em",[s._v("(?=.{6,})(?=.")]),s._v("\\d)(?=."),e("em",[s._v("[A-Z])(?=.")]),s._v("[a-z])(?=."),e("em",[s._v("[!@#$%^&")]),s._v("? ]).*$/     密码强度正则，最少 6 位，包括至少 1 个大写字母，1 个小写字母，1 个数字，1 个特殊字符 (包含了5个if条件，wow)")]),s._v(" "),e("li",[s._v("/^((https?|ftp|file)😕/)?([\\da-z.-]+).([a-z.]{2,6})([/\\w .-]"),e("em",[s._v(")")]),s._v("/?$/   URL 正则")])]),s._v(" "),e("h2",{attrs:{id:"应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[s._v("#")]),s._v(" 应用")]),s._v(" "),e("ul",[e("li",[s._v("sed")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('sed 文本工具支持：BREs、EREs\n\nsed 指令默认是使用"BREs"\n\nsed 命令参数 “-r ” ，则表示要使用“EREs"\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("ul",[e("li",[s._v("grep")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('grep 支持：BREs、EREs、PREs 正则表达式\n\ngrep 指令后不跟任何参数，则表示要使用 ”BREs“ \n\ngrep 指令后跟 ”-E" 参数，则表示要使用 “EREs“\n\ngrep 指令后跟 “-P" 参数，则表示要使用 “PREs"\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])])])}),[],!1,null,null,null);a.default=v.exports}}]);