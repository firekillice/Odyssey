(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{449:function(s,a,t){s.exports=t.p+"assets/img/ccompilerlinker007.173ab5ce.png"},450:function(s,a,t){s.exports=t.p+"assets/img/1458743340-5ddbcaa6525a5_articlex.f614297c.png"},657:function(s,a,t){"use strict";t.r(a);var e=t(26),r=Object(e.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"内存管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[s._v("#")]),s._v(" 内存管理")]),s._v(" "),e("p",[e("img",{attrs:{src:t(449),alt:"mem-simple"}}),s._v(" "),e("img",{attrs:{src:t(450),alt:"kernel&process&detail"}})]),s._v(" "),e("h2",{attrs:{id:"内核栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内核栈"}},[s._v("#")]),s._v(" 内核栈")]),s._v(" "),e("ul",[e("li",[s._v("一个用户态进程/线程在内核中都是用一个task_struct的实例描述的，这个有点类似设计模式里面的桥接模式(handle-body), 用户态看到的进程PID，线程TID都是handle, task_struct是body")]),s._v(" "),e("li",[s._v("C语言书里面讲的堆、栈大部分都是用户态的概念，用户态的堆、栈对应用户进程虚拟地址空间里的一个区域，栈向下增长，堆用malloc分配，向上增长。用户空间的堆栈，在task_struct->mm->vm_area里面描述，都是属于进程虚拟地址空间的一个区域。")]),s._v(" "),e("li",[s._v("内核态的栈在tsak_struct->stack里面描述，其底部是thread_info对象，thread_info可以用来快速获取task_struct对象。所以一个进程的内核栈，也是进程私有的，只是在task_struct->stack里面获取。")]),s._v(" "),e("li",[s._v("内核态没有堆的概念，用kmalloc()分配内存，实际上是Linux内核统一管理的，一般用slab分配器，也就是一个内存缓存池，管理所有可以kmalloc()分配的内存。所以从原理上看，在Linux内核态，kmalloc分配的所有的内存，都是可以被所有运行在Linux内核态的task访问到的。")]),s._v(" "),e("li",[s._v("code")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("struct task_struct {\n volatile long state; /* -1 unrunnable, 0 runnable, >0 stopped */\n void *stack;\n atomic_t usage;\n unsigned int flags; /* per process flags, defined below */\n unsigned int ptrace;\n int lock_depth; /* BKL lock depth */ \n /* ...... */ \n};\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br")])]),e("ul",[e("li",[s._v("每个进程被创建的时候，在生成进程描述符task_struct的同时，会生成两个栈，一个是用户栈，位于用户地址空间；一个是内核栈，位于内核空间。当进程在用户地址空间中执行的时候，使用的是用户栈，CPU堆栈指针寄存器中存的是用户栈的地址；同理，当进程在内核空间执行时，CPU堆栈指针寄存器中放的是内核栈的地址。")]),s._v(" "),e("li",[s._v("当位于用户空间的进程进行系统调用时，它会陷入内核，让内核代其执行。此时，进程用户栈的地址会被存进内核栈中，CPU堆栈指针寄存器中的内容也会变为内核栈的地址。当系统调用执行完毕，进程从内核栈找到用户栈的地址，继续在用户空间中执行，此时CPU堆栈指针寄存器就变为了用户栈的地址。")])]),s._v(" "),e("h2",{attrs:{id:"real-mode-protected-mode"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#real-mode-protected-mode"}},[s._v("#")]),s._v(" real mode & protected mode")]),s._v(" "),e("ul",[e("li",[s._v("real mode 就是直接访问物理内存")]),s._v(" "),e("li",[s._v("保护模式是利用虚拟地址访问物理内存")])]),s._v(" "),e("h2",{attrs:{id:"几个地址概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#几个地址概念"}},[s._v("#")]),s._v(" 几个地址概念")]),s._v(" "),e("ul",[e("li",[s._v("线性地址(linear address是intel手册中使用的概念) == 虚拟地址(内核中使用的概念)")]),s._v(" "),e("li",[s._v("逻辑地址 == 相对地址: selector:offset")]),s._v(" "),e("li",[s._v("物理地址: 内存的直接地址")]),s._v(" "),e("li",[s._v('转换： 汇编指令中使用的是相对地址，需要使用"段式内存管理"转为线性地址，然后利用"页式内存管理"转为物理地址')]),s._v(" "),e("li",[s._v("段式内存管理: 利用selector:offset，对应的CS:IP两个寄存器中的值，使用GDT(Global Descriptor Table，对应的内核的段)和LDT(Local Descriptor Table，对应用户的代码段)找到段对应的起始地址")])]),s._v(" "),e("h2",{attrs:{id:"intel定义的三大表子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#intel定义的三大表子"}},[s._v("#")]),s._v(" intel定义的三大表子")]),s._v(" "),e("ul",[e("li",[s._v("IDT(Interrupt Descriptor Table)")]),s._v(" "),e("li",[s._v("LDT ( Local Descriptor Table)")]),s._v(" "),e("li",[s._v("GDT ( Global Descriptor Table )")]),s._v(" "),e("li",[s._v("不知道为什么，总是喜欢使用Descriptor这个词")])]),s._v(" "),e("h2",{attrs:{id:"tss-task-state-segment"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tss-task-state-segment"}},[s._v("#")]),s._v(" TSS(Task State Segment)")]),s._v(" "),e("ul",[e("li",[s._v("进程的任务状态段信息结构。在任务从执行中被切换出时tss_struct结构保存了当前处理器的所有寄存器值。当任务又被CPU重新执行时，CPU就会利用这些值恢复到任务被切换出时的状态，并开始执行。")])]),s._v(" "),e("h2",{attrs:{id:"理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#理解"}},[s._v("#")]),s._v(" 理解")]),s._v(" "),e("ul",[e("li",[s._v("在内核栈上可以操作一切用户态的数据的")]),s._v(" "),e("li",[s._v("一定要时刻谨记用户态还是内核态")]),s._v(" "),e("li",[s._v("不管是内核态还是用户态执行，都是同一个进程在运行")]),s._v(" "),e("li",[s._v("在内核态，堆、栈、向下增长等概念都消失不见了")])]),s._v(" "),e("h2",{attrs:{id:"mmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mmap"}},[s._v("#")]),s._v(" mmap")]),s._v(" "),e("ul",[e("li",[s._v("实现文件地址空间与虚拟地址空间的映射")]),s._v(" "),e("li",[s._v("间接效果，通过文件做为关联实现两个进程间共享内存")]),s._v(" "),e("li",[s._v("比较swap，也是内存与硬盘的勾兑")])]),s._v(" "),e("h2",{attrs:{id:"swap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#swap"}},[s._v("#")]),s._v(" swap")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("> free -m \n              total        used        free      shared  buff/cache   available\nMem:           2827         465        1201          14        1160        2092\nSwap:          2048         135        1913\n> swapon -s\nFilename                                Type            Size    Used    Priority\n/dev/sda2                               partition       2098172 139008  -2\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])])])}),[],!1,null,null,null);a.default=r.exports}}]);