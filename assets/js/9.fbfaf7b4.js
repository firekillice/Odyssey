(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{505:function(s,e,t){s.exports=t.p+"assets/img/hdd-working.bda0d3f9.gif"},506:function(s,e,t){s.exports=t.p+"assets/img/Hard_drive_geometry.61fbf5f8.png"},507:function(s,e,t){s.exports=t.p+"assets/img/ssd-inner-layout.4a417d8a.png"},508:function(s,e,t){s.exports=t.p+"assets/img/ext4-layout.cd9ce15d.png"},509:function(s,e,t){s.exports=t.p+"assets/img/ext4-inline-layout.b59647f9.png"},510:function(s,e,t){s.exports=t.p+"assets/img/ext4-extent-layout.e10e097f.png"},511:function(s,e,t){s.exports=t.p+"assets/img/2000feet-view-hdd2mem.a9f0ceae.png"},512:function(s,e,t){s.exports=t.p+"assets/img/fs-all-in-one.327c634f.png"},576:function(s,e,t){"use strict";t.r(e);var a=t(36),n=Object(a.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"磁盘和内存如何聊天"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#磁盘和内存如何聊天"}},[s._v("#")]),s._v(" 磁盘和内存如何聊天")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("不做特殊说明的话，本文涉及到的内容都基于x86体系和Linux6.14内核。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("本文尝试探讨硬盘和文件系统的基本概念、工作原理及其相互关系。首先介绍了机械硬盘（HDD）和固态硬盘（SSD）的基本工作原理，分析文件系统的结构与工作原理，介绍了如何使用命令行对文件和硬盘进行地址映射,最后概述文件读写的基本过程，内容适合非内核开发人员阅读，能够对linux的文件系统建立一个比较全面的认识。如果有内存的一些问题可以我的上一篇文章"),a("RouterLink",{attrs:{to:"/insight/mem-2-cache.html"}},[s._v("内存和缓存的如何聊天")]),s._v(".")],1),s._v(" "),a("h2",{attrs:{id:"先说说磁盘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#先说说磁盘"}},[s._v("#")]),s._v(" 先说说磁盘")]),s._v(" "),a("h3",{attrs:{id:"机械磁盘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#机械磁盘"}},[s._v("#")]),s._v(" 机械磁盘")]),s._v(" "),a("ul",[a("li",[s._v("大体的运动与工作方式，"),a("img",{attrs:{src:t(505),alt:"hdd-working"}})]),s._v(" "),a("li",[s._v("磁性存储技术是一种基于磁场变化来存储和检索数据的技术。它利用磁性材料的性质，通过改变磁场的方向或强度来表示数据的0和1。")]),s._v(" "),a("li",[a("img",{attrs:{src:t(506),alt:"Hard_drive_geometry"}}),s._v(" 图片来源wikipedia，从图中可以看出，磁盘根据柱面（Cylinder）、磁头（Header）和扇区（Sector）分成三个层次，三者简称CHS，可以使用"),a("strong",[s._v("坐标系xyz")]),s._v("来理解。")]),s._v(" "),a("li",[s._v("磁盘的最小寻址单元为sector,即只要磁头运行到扇区的上方就可以把数据读取了，一般为512B或者4KB，"),a("a",{attrs:{href:"https://www.seagate.com/content/dam/seagate/migrated-assets/www-content/datasheets/pdfs/barracuda-2-5-DS1907-3-2005CN-zh_CN.pdf",target:"_blank",rel:"noopener noreferrer"}},[s._v("seagate产品参数"),a("OutboundLink")],1),s._v("从这上面可以看到，物理扇区其实是4KB，但是逻辑上保持512，也就是所谓的512e，还有512n，这种就是传统的物理和逻辑上都是512n，目前比较新的是4Kn，逻辑和物理上都是4K")]),s._v(" "),a("li",[s._v("磁盘读写数据的时候不会停止，而是保持一直旋转的状态，只要磁头到了扇区的上方，即使在磁盘高速转动的情况下数据也会立刻就被读取或者写入进去。")]),s._v(" "),a("li",[s._v("每个盘面只有一个磁头 所有的磁头都是连在同一个磁臂上的，并且在相同的轨道上，所有磁头只能"),a("strong",[s._v("共进退")])]),s._v(" "),a("li",[s._v('关于不同盘面之间的写入顺序问题有不同的说法，最常见的是"同一时刻只能有一个磁头在工作，磁头的切换可以通过电路进行控制，而选择柱面则需要机械切换，所以数据的存储优先按柱面顺序进行，以减少磁头的移动时间"')])]),s._v(" "),a("h3",{attrs:{id:"ssd-solid-state-disk"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ssd-solid-state-disk"}},[s._v("#")]),s._v(" SSD(Solid-State Disk)")]),s._v(" "),a("ul",[a("li",[s._v("Flash Memory: 闪(此处的闪应该是相对于机械磁盘那种龟速来说的)存，分为NOR(Not Or)闪存（BIOS中使用）和NAND(Not And与非门)闪存，一般情况NOR Flash容量较小，NAND Flash容量较大，比如U盘和SSD固态硬盘。")]),s._v(" "),a("li",[s._v("所有信息都存储在浮栅晶体管，对于不想理解硬件的程序员来说，可以记住它就是电子牢笼，里面有电子就代表0，没有电子代表1（是不是与你想的不一样，所以默认值是1），所以SSD的写操作是将1变为0，不会从0变为1，那个操作需要使用"),a("strong",[s._v("擦除")]),s._v("，后面说到。")]),s._v(" "),a("li",[s._v("重要概念\n"),a("ul",[a("li",[a("strong",[s._v("Block")]),s._v(": 最小的擦除单位")]),s._v(" "),a("li",[a("strong",[s._v("Page")]),s._v(": 最小的读写单位")]),s._v(" "),a("li",[a("strong",[s._v("Plane")]),s._v(": 组，提供并行读写能力")]),s._v(" "),a("li",[a("strong",[s._v("Die")]),s._v(":  晶圆，封装多个Plane\n他们之间的关系如下\n"),a("img",{attrs:{src:t(507),alt:"ssd-inner-layout"}})])])]),s._v(" "),a("li",[a("strong",[s._v("关于电压")]),s._v("：\n"),a("ul",[a("li",[s._v("SSD的工作电压大概是3-5v，写电压大概是10-20v，而擦除电压需要比写电压更高，对比一下DRAM的充电电压才1-3v，差了相当多。")]),s._v(" "),a("li",[s._v("也就是高电压才能让电子穿过绝缘层被囚禁起来稳定的保存10年之久，带来的影响是，如果在绝缘层上高电压的次数多了，绝缘层也就失效了，所以SSD的Block都有擦除次数上限。")]),s._v(" "),a("li",[s._v("因为Page的电子状态是由Block的电气特性决定的。如果只擦除某一页面，会导致页面之间的 电压不一致，从而造成无法控制的读写错误。")])])]),s._v(" "),a("li",[a("strong",[s._v("GC")]),s._v(": 对开发人员都不陌生，SSD也有GC，就是将标记为无效的Page进行收集归拢")]),s._v(" "),a("li",[a("strong",[s._v("磨损均衡")]),s._v(": 为了防止某一个Block运气不好被反复的擦除直到累死(可擦除次数耗尽)，SSD的控制器为了防止这种情形发生而进行的操作。")]),s._v(" "),a("li",[a("strong",[s._v("FTL(Flash Translation Layer)")]),s._v(": 在进行擦除的时候需要进行数据的移动，所以数据的地址关系就发生了变化，为了保证寻址，固态磁盘使用FTL记录数据的映射关系。")])]),s._v(" "),a("h2",{attrs:{id:"对磁盘寻址的抽象lba-logical-block-address"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对磁盘寻址的抽象lba-logical-block-address"}},[s._v("#")]),s._v(" 对磁盘寻址的抽象LBA(Logical Block Address)")]),s._v(" "),a("p",[s._v("为了应对机械磁盘配置参数的多样性以及固态硬盘的存储模式，操作系统中使用了LBA抽象了统一的、线性地址空间，不再关心具体的物理特性。")]),s._v(" "),a("ul",[a("li",[s._v("对于机械磁盘而言, LBA转为CHS，方式如下")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("cylinder：磁盘的柱面\nhead：磁盘的磁头，每张磁片有两个磁头\nsector：磁盘扇区，这里指物理扇区，编号从 1 - 63，每条 track 的最大 sector 数 63\nSPT（sector_per_track）：每磁道上的 sector 数\nHPC（head_per_cylinder）：每个 cylinder 的 head 数量，这个数量应该是磁片数 * 2\n\nLBA = (cylinder * HPC + head) * SPT + sector - 1\n\ncylinder = LBA / (SPT * HPC)\nhead = (LBA / SPT) % HPC\nsector = LBA % SPT + 1\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("ul",[a("li",[s._v("对于SSD而言, LBA转为PBA(Physical Block Address)，使用FTL进行，这个由SSD自动完成，操作系统不用关心。")]),s._v(" "),a("li",[s._v("查看磁盘的IO调度策略")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("cat /sys/block/sr0/queue/scheduler \nnoop [deadline] cfq  带有[]是当前使用的\nnoop： 不做任何调度，将写请求放入FIFO队列\ndeadline：按照过期时间存储\ncfq(Completely Fair Queueing): 防止IO分配的不公平，防止某些进程独占磁盘带宽\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("ul",[a("li",[s._v("查看磁盘的块大小 blockdev --getbsz /dev/sda")]),s._v(" "),a("li",[s._v("存储的时候需要在Page(内存)、Block(文件系统)、Sector(硬件读写)之间进行单位的组织与转换，Block作为中间单元，大小上一般Page >= Block >= Sector")])]),s._v(" "),a("h2",{attrs:{id:"内存和硬盘的桥梁-文件系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存和硬盘的桥梁-文件系统"}},[s._v("#")]),s._v(" 内存和硬盘的桥梁--文件系统")]),s._v(" "),a("ul",[a("li",[s._v("文件系统在操作系统中扮演着连接磁盘（持久存储）和内存（临时存储）之间的桥梁作用。它负责管理磁盘上的数据如何存储、如何访问，以及如何通过内存进行缓存和处理。Linux支持多种类型的文件系统，比如ext4，btrfs、xfs、zfs、jfs等。ext4（第四代扩展文件系统）是目前 Linux 系统中最常用的文件系统之一，我们以此为例展开介绍。")])]),s._v(" "),a("h3",{attrs:{id:"先感受一下inode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#先感受一下inode"}},[s._v("#")]),s._v(" 先感受一下inode")]),s._v(" "),a("ul",[a("li",[s._v("查看文件inode number")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("> ls -i example.txt \n87664379 example.txt\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("inode number 其实就是在inode bitmap中的编号")])]),s._v(" "),a("h3",{attrs:{id:"使用dumpe2fs查看一下文件系统的基础信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用dumpe2fs查看一下文件系统的基础信息"}},[s._v("#")]),s._v(" 使用dumpe2fs查看一下文件系统的基础信息")]),s._v(" "),a("ul",[a("li",[s._v("dumpe2fs中的信息\n"),a("ul",[a("li",[s._v("dumpe2fs /dev/vda1 中包含了丰富的信息")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Blocks per group:         32768 每个组的Block数目\nInodes per group:         8192  每个组的Inode数目\nBlock size:               4096  Block的大小\nInode size:               256   Inode 字段的大小\nInodes per group:         8192  每组的Inode的数量\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("ul",[a("li",[s._v("dumpe2fs /dev/vda1  | grep Group查看组的个数")]),s._v(" "),a("li",[s._v("dumpe2fs /dev/vda1  | grep superblock")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Primary superblock at 0, Group descriptors at 1-3\nBackup superblock at 32768, Group descriptors at 32769-32771\nBackup superblock at 98304, Group descriptors at 98305-98307\n超级块为了冗余在多个块上都有存储，但是Primary的在Block 0上\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("ul",[a("li",[s._v("针对每个组")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("  Block bitmap at 1025 (+1025) 组的Block bitmap 在Block 1025 \n  Inode bitmap at 1041 (+1041) 组的Inode bitmap 在Block 1041\n  Inode table at 1057-1568 (+1057) Inode Table 在1057-1568 \n  使用这个可以算得 (1568-1057 + 1)* 4 * 1024 / 256(Inode Size) = 8192和上面的8192对应\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])])]),s._v(" "),a("li",[s._v("如果没有现成的ext的磁盘可以使用如下的方式生成并挂载一个")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("dd if=/dev/zero of=./ext4_image.img bs=1M count=64\nmkfs.ext4 ext4_image.img\nmount -o loop ext4_image.img /root/test_ext4\ndumpe2fs ext4_image.img\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("h3",{attrs:{id:"组织结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组织结构"}},[s._v("#")]),s._v(" 组织结构")]),s._v(" "),a("p",[a("img",{attrs:{src:t(508),alt:"ext4-layout"}})]),s._v(" "),a("ul",[a("li",[s._v("ext4将申请到的整个空间分为了多个组")]),s._v(" "),a("li",[s._v("超级块在多个组中都存在")]),s._v(" "),a("li",[s._v("inode bitmap 和inode table 一一对应，个数在文件系统生成的时候就已经预制好了")]),s._v(" "),a("li",[s._v("每个文件对应一个inode，所以使用过程中可能会出现磁盘空间还有很多inode使用耗尽无法创建文件的情形。")]),s._v(" "),a("li",[s._v("blok bitmap 记录了block的使用情况")]),s._v(" "),a("li",[s._v("数据部分的使用方式在于选择了什么样的文件组织形式，目前有inline和extent两种方式，下面会详细介绍")]),s._v(" "),a("li",[s._v("文件系统可以使用mount挂载到某个目录中，所以文件系统的使用允许嵌套")])]),s._v(" "),a("h3",{attrs:{id:"单个文件组织形式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单个文件组织形式"}},[s._v("#")]),s._v(" 单个文件组织形式")]),s._v(" "),a("p",[s._v("不管是哪种模式，入口都是struct ext4_inode的i_block字段，一共4*15=60B。不管是哪种结构，都应该都够"),a("code",[s._v("通过在文件中的偏移量转为对应的Block编号")]),s._v("。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("struct ext4_inode\n{\n  ...\n  __le32\ti_block[EXT4_N_BLOCKS];/* Pointers to blocks */\n  ...\n}\n#define\tEXT4_NDIR_BLOCKS\t\t12\n#define\tEXT4_IND_BLOCK\t\t\tEXT4_NDIR_BLOCKS\n#define\tEXT4_DIND_BLOCK\t\t\t(EXT4_IND_BLOCK + 1)\n#define\tEXT4_TIND_BLOCK\t\t\t(EXT4_DIND_BLOCK + 1)\n#define\tEXT4_N_BLOCKS\t\t\t(EXT4_TIND_BLOCK + 1)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("h4",{attrs:{id:"inline模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inline模式"}},[s._v("#")]),s._v(" inline模式")]),s._v(" "),a("ul",[a("li",[a("img",{attrs:{src:t(509),alt:"ext4-inline-layout"}})]),s._v(" "),a("li",[s._v("这种模式下，入口包括12个直接块和1一个一级索引、一个二级索引、一个三级索引组成。当12个直接块够用的时候，就不会生成一级索引，同样，一级索引够用的时候，也不会生成二级索引。")]),s._v(" "),a("li",[s._v("一个块按照4KB计算，一个索引其实就是一个整数使用4B，则一个索引中可以包含4KB/4B=1024个数据。")]),s._v(" "),a("li",[s._v("没有索引直接块能存储4KB * 12")]),s._v(" "),a("li",[s._v("一级索引数据写满的时候，最大文件为  (12 + 1024) * 4KB 大约为4KB")]),s._v(" "),a("li",[s._v("二级索引数据写满的时候，最大文件为  (12 + 1024 + 1024 * 1024) * 4KB 大约为4GB")]),s._v(" "),a("li",[s._v("一级索引数据写满的时候，最大文件为  (12 + 1024 + 1024 * 1024 + 1024 * 1024 * 1024) * 4KB 大约4TB")])]),s._v(" "),a("h3",{attrs:{id:"extent模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#extent模式"}},[s._v("#")]),s._v(" extent模式")]),s._v(" "),a("p",[s._v("使用B+树的方式组织在一起，只有叶子节点才存储真正的数据，在非叶子节点内部用二分查找迅速定位逻辑块所在的索引，详见内核代码中ext4_ext_binsearch_idx这个函数。使用该树就可以使用"),a("strong",[s._v("32B的文件块编号")]),s._v("迅速定位"),a("strong",[s._v("某个48b的物理块号")]),s._v("。\n"),a("img",{attrs:{src:t(510),alt:"ext4-extent-layout"}})]),s._v(" "),a("h4",{attrs:{id:"ext4-extent-header-数据块头"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ext4-extent-header-数据块头"}},[s._v("#")]),s._v(" ext4_extent_header 数据块头")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("struct ext4_extent_header {\n        __le16  eh_magic;       /* probably will support different formats */\n        __le16  eh_entries;     /* number of valid entries */\n        __le16  eh_max;         /* capacity of store in entries */\n        __le16  eh_depth;       /* has tree real underlying blocks? */ \n        __le32  eh_generation;  /* generation of the tree */ \n};\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("h4",{attrs:{id:"ext4-extent-idx-索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ext4-extent-idx-索引"}},[s._v("#")]),s._v(" ext4_extent_idx 索引")]),s._v(" "),a("p",[s._v("extent模式下每个块都有一个ext4_extent_header放在块的头部。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("struct ext4_extent_idx {\n        __le32  ei_block;       /* index covers logical blocks from 'block' */ \n        __le32  ei_leaf_lo;     /* pointer to the physical block of the next *\n                                 * level. leaf or next index could be there */\n        __le16  ei_leaf_hi;     /* high 16 bits of physical block */\n        __u16   ei_unused;\n};\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("ei_block 是对应的文件的逻辑块号，比如offset为5987，如果按照4KB块大小的话，它所在的Block Index就是1\nei_leaf_hi和ei_leaf_lo组成了下一个物理块的地址。")]),s._v(" "),a("h4",{attrs:{id:"ext4-extent-extent的具体映射信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ext4-extent-extent的具体映射信息"}},[s._v("#")]),s._v(" ext4_extent extent的具体映射信息")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("struct ext4_extent {\n        __le32  ee_block;       /* first logical block extent covers */\n        __le16  ee_len;         /* number of blocks covered by extent */\n        __le16  ee_start_hi;    /* high 16 bits of physical block */ \n        __le32  ee_start_lo;    /* low 32 bits of physical block */\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("ee_block是第一个文件逻辑块的开始位置，ee_len表示长度，ee_start_hi和ee_start_lo表示第一块的物理块位置，其实这个就描述了两个区段的对应关系，长度为ee_len * BlockSize。")]),s._v(" "),a("h3",{attrs:{id:"不得不提起的mbr-master-boot-record-和gpt-guid-partition-table"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不得不提起的mbr-master-boot-record-和gpt-guid-partition-table"}},[s._v("#")]),s._v(" 不得不提起的MBR(Master Boot Record)和GPT(GUID Partition Table)")]),s._v(" "),a("ul",[a("li",[s._v("都是用于磁盘分区的标准")]),s._v(" "),a("li",[s._v("MBR, 1983年开始使用，不支持大于2T的磁盘")]),s._v(" "),a("li",[s._v("GPT，2006年以后的标准")])]),s._v(" "),a("h2",{attrs:{id:"说了这么多-到底文件如何在内存和硬盘之间如何传输呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说了这么多-到底文件如何在内存和硬盘之间如何传输呢"}},[s._v("#")]),s._v(" 说了这么多，到底文件如何在内存和硬盘之间如何传输呢")]),s._v(" "),a("p",[s._v("由于磁盘和内存之间速度差异较大，因此在它们之间加入缓存成为必要选择，操作系统自身就配备了PageCache，在用户态使用的时候，因为系统调用的代价问题，标准库中的io读写又加了一个用户态的缓存，最终成为了下面的样子。\n"),a("img",{attrs:{src:t(511),alt:"2000feet-view-hdd2mem"}}),s._v("\n我们把镜头下推看看细节吧，先上一个较为详细的图\n"),a("img",{attrs:{src:t(512),alt:"fs-all-in-one"}})]),s._v(" "),a("h3",{attrs:{id:"涉及到的重要的数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#涉及到的重要的数据结构"}},[s._v("#")]),s._v(" 涉及到的重要的数据结构")]),s._v(" "),a("h5",{attrs:{id:"task-struct"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#task-struct"}},[s._v("#")]),s._v(" task_struct")]),s._v(" "),a("p",[s._v("linux下每个进程都会对应一个task_struct，里面包含该进程的重要信息")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("struct task_struct {\n  ...\n  struct fs_struct\t\t*fs;\n  struct files_struct\t\t*files;\n  ...\n  /* Stacked block device info: */\n\tstruct bio_list\t\t\t*bio_list;\n\t/* Stack plugging: */\n\tstruct blk_plug\t\t\t*plug;\n  ...\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("h5",{attrs:{id:"bio"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bio"}},[s._v("#")]),s._v(" bio")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("struct bio { //main unit of I/O for the block layer and lower layers \n  ...\n  struct block_device\t*bi_bdev\n  ...\n  struct bio_vec\t\t*bi_io_vec;\t/* the actual vec list */\n  ...\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("h5",{attrs:{id:"bio-vec"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bio-vec"}},[s._v("#")]),s._v(" bio_vec")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("struct bio_vec { //a contiguous range of physical memory addresses\n\tstruct page\t*bv_page;  //数据所在的页\n\tunsigned int\tbv_len;   //数据的总长度\n\tunsigned int\tbv_offset; //数据在该页的偏移\n};\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h5",{attrs:{id:"page"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#page"}},[s._v("#")]),s._v(" page")]),s._v(" "),a("p",[s._v("内存的分页")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("struct page {\n  //Each physical page in the system has a struct page associated with\n * it to keep track of whatever it is we are using the page for at the\n * moment.\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h5",{attrs:{id:"request"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#request"}},[s._v("#")]),s._v(" request")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("struct request {\n    ...\n  \tstruct bio *bio;\n    ...\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("从上述代码定义可以看出，request运载bio，bio运载page中的数据段信息。")]),s._v(" "),a("h5",{attrs:{id:"blk-plug"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blk-plug"}},[s._v("#")]),s._v(" blk_plug")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v(" /*blk_plug permits building a queue of related requests by holding the I/O\n * fragments for a short period. This allows merging of sequential requests\n * into single larger request. As the requests are moved from a per-task list to\n * the device's request_queue in a batch, this results in improved scalability\n * as the lock contention for request_queue lock is reduced./\nstruct blk_plug {\n  struct rq_list mq_list; /* blk-mq requests */\n  ...\n}\nstruct rq_list {\n\tstruct request *head;\n\tstruct request *tail;\n};\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("h4",{attrs:{id:"如何从文件的offset定位到硬盘上的block"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何从文件的offset定位到硬盘上的block"}},[s._v("#")]),s._v(" 如何从文件的Offset定位到硬盘上的Block")]),s._v(" "),a("ul",[a("li",[s._v('文件的fd和offset，形成了一个类似"射线"的线性空间')]),s._v(" "),a("li",[s._v("使用hdparm命令,获取文件在磁盘中的LBA的起始与终止的LBA")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("hdparm --fibmap /root/1.txt \n1.txt:\n filesystem blocksize 4096, begins at LBA 2048; assuming 512 byte sectors.\n byte_offset  begin_LBA    end_LBA    sectors\n           0   22450344   22450367         24\n起始LBA：22450344\n终止LBA：22450367\nsector个数： 24\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("filefrag -e /root/1.txt                       \nFilesystem type is: ef53\nFile size of 1.txt is 11279 (3 blocks of 4096 bytes)\n ext:     logical_offset:        physical_offset: length:   expected: flags:\n   0:        0..       2:    2806037..   2806039:      3:             eof\n\n在文件系统中的开始block为2806037，结束block为2806039，占用了3个block\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('debugfs -R "stat /root/1.txt"  /dev/vda1\ndebugfs 1.42.9 (28-Dec-2013)\nInode: 1053681   Type: regular    Mode:  0644   Flags: 0x80000\nGeneration: 59906683    Version: 0x00000000:00000001\nUser:     0   Group:     0   Size: 11279\nFile ACL: 0    Directory ACL: 0\nLinks: 1   Blockcount: 24\nFragment:  Address: 0    Number: 0    Size: 0\n ctime: 0x67bb1a53:0ef38134 -- Sun Feb 23 20:53:39 2025\n atime: 0x67bb1a53:0e796ddc -- Sun Feb 23 20:53:39 2025\n mtime: 0x67bb1a53:0e796ddc -- Sun Feb 23 20:53:39 2025\ncrtime: 0x67bb1a53:0e796ddc -- Sun Feb 23 20:53:39 2025\nSize of extra inode fields: 28\nEXTENTS:\n(0-2):2806037-2806039\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("lsblk -l\nNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT\nvda  253:0    0  40G  0 disk \nvda1 253:1    0  40G  0 part /\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("fdisk -l\n\nDisk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x000beb6e\n   Device Boot      Start         End      Blocks   Id  System\n/dev/vda1   *        2048    83886046    41941999+  83  Linux\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("从以上信息可以得到，/root/1.txt位于/dev/vda1分区下，大小为3个block，24个sector，在硬盘上的位置为LBA 22450344-22450367， 文件系统中的位置为Block 2806037-2806039，/dev/vda1的开始sector为2048，我们来算一下这其中的关系,"),a("code",[s._v("22450344 = 2806037 * 8 （一个block8个sector） + 2048")]),s._v("。\n所以当确定一个文件的某个offset在硬盘上的位置的时候，首先计算offset所对应的文件的"),a("strong",[s._v("文件块号")]),s._v("(offset/4096)， 然后从inline或者extent模式的结构中获取"),a("strong",[s._v("文件块号")]),s._v("所对应的逻辑块号，然后根据上面所说的对应关系就可以算出在磁盘上的sector或者说LBA，然后转为PBA就由驱动或者硬件自身完成了。")]),s._v(" "),a("h4",{attrs:{id:"io读写基本路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#io读写基本路径"}},[s._v("#")]),s._v(" IO读写基本路径")]),s._v(" "),a("ol",[a("li",[s._v("从用户态内存写入到内核的Page缓存中，该Page可以从struct address_space中进行寻址，该结构以前是通过一个基数树(radix tree)进行查找，新版的linux已经使用xarray进行管理了。")]),s._v(" "),a("li",[s._v("从Page缓存生成bio，放入到bio list，bio中包含了要操作的数据区间，具体结构可以看下方的代码。")]),s._v(" "),a("li",[s._v("从bio list到 进程的blk_plug，其实这是一个request队列，request是设备驱动直接操作的结构体，request中包含多个bio，可以认为是bio的载具。那个出名的电梯算法也是在对request进行处理的。")]),s._v(" "),a("li",[s._v("放入到设备驱动的request queue，最终读写硬盘")]),s._v(" "),a("li",[s._v("小结\n"),a("ul",[a("li",[s._v("文件读写stack大概为: 用户内存<--\x3e内核PageCache<--\x3ebio<--\x3erequest，这样一个大体的流程")]),s._v(" "),a("li",[s._v("page cache对于每个文件(inode)一份")]),s._v(" "),a("li",[s._v("bio list放在进程的task_struct中")]),s._v(" "),a("li",[s._v("task_struct中提供了struct blk_plug* plug，对bio进行段时间的缓存和优化合并")]),s._v(" "),a("li",[s._v("进入到设备驱动的request也会进一步的合并与优化，根据io调度器进行QoS等。")])])])]),s._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("p",[s._v("本文对磁盘、文件系统、IO读写等都做了一定的描述，存储模块非常的复杂，这里仅仅描述到非内核开发人员适合的水平，如果遗漏或者可以提供更深的描述，欢迎补充与评论。涉及到的内容比较多难免有所疏漏，如有错误，也望不吝指出，感谢。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("微信公众号为“吹风的坚果”，欢迎关注，定期更新优质的计算机文章。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h3",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[s._v("#")]),s._v(" 参考")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.ilinuxkernel.com/files/Linux.Generic.Block.Layer.pdf",target:"_blank",rel:"noopener noreferrer"}},[s._v("Linux通用块设备层"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://www.eet-china.com/mp/a263944.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("Linux文件读写（BIO）波澜壮阔的一生"),a("OutboundLink")],1)]),s._v(" "),a("li",[a("a",{attrs:{href:"https://www.kernel.org/doc/html/latest/filesystems/ext4/ifork.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("关于i_block"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=n.exports}}]);