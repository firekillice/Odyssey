(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{359:function(a,s,t){a.exports=t.p+"assets/img/jsMYZ.e16e4213.png"},360:function(a,s,t){a.exports=t.p+"assets/img/320px-Example_syntax_diagram_3.svg.da3e75ed.png"},361:function(a,s,t){a.exports=t.p+"assets/img/152370204511225.58b06e1b.jpg"},362:function(a,s,t){a.exports=t.p+"assets/img/crm-turing_test.964a3796.jpg"},616:function(a,s,t){"use strict";t.r(s);var r=t(26),e=Object(r.a)({},(function(){var a=this,s=a.$createElement,r=a._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"形式语言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#形式语言"}},[a._v("#")]),a._v(" 形式语言")]),a._v(" "),r("h2",{attrs:{id:"基础"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[a._v("#")]),a._v(" 基础")]),a._v(" "),r("ul",[r("li",[a._v("Formal language用精确的数学或机器可处理的公式定义的语言。")]),a._v(" "),r("li",[a._v("语言定义在某一个特定的字母表上，字母表（经常记作 Σ ）可以为任意有限集合。例如集合{a,b,c...,z}就表示所有小写字母构成的字母表。")])]),a._v(" "),r("h2",{attrs:{id:"形式系统"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#形式系统"}},[a._v("#")]),a._v(" 形式系统")]),a._v(" "),r("ul",[r("li",[a._v("形式系统（英语：Formal system）是由两个部分组成的，一个形式语言加上一个推理规则或转换规则的集合。")])]),a._v(" "),r("h2",{attrs:{id:"形式化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#形式化"}},[a._v("#")]),a._v(" 形式化")]),a._v(" "),r("ul",[r("li",[a._v("即所有的内存对象都有一个符号进行对应")])]),a._v(" "),r("h2",{attrs:{id:"形式文法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#形式文法"}},[a._v("#")]),a._v(" 形式文法")]),a._v(" "),r("ul",[r("li",[a._v("枚举也是文法的一种")]),a._v(" "),r("li",[a._v("是形式语言中字符串的一套产生式规则。这些规则描述了如何用语言的字母表生成符合语法的有效的字符串。")]),a._v(" "),r("li",[a._v("乔姆斯基(Chomsky于1956年建立形式语言的描述以来，形式语言的理论发展很快。他将文法分成四种类型，即0型、1型、2型和3型，0型即自然语言文法，1型称为上下文相关文法，2型称为上下文无关文法(context-free grammar，CFG)，3型称为正则文法。看到哲学家对计算机科学的贡献，也是计算机和哲学的交叉部分。")])]),a._v(" "),r("h2",{attrs:{id:"范式-normal-form"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#范式-normal-form"}},[a._v("#")]),a._v(" 范式 (Normal Form)")]),a._v(" "),r("ul",[r("li",[a._v("范式就是惯例，只不过为了将这个行为给特化出来的新设计的词语，就如同大革命，大萧条都有其特指一样。本质上讲和设计模式是同一种性质的概念。")]),a._v(" "),r("li",[a._v("范式是将一种非理性的思维方式引入到数学领域，处于理性科学与感性科学的边缘。")])]),a._v(" "),r("h3",{attrs:{id:"bnf-巴科斯范式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bnf-巴科斯范式"}},[a._v("#")]),a._v(" BNF 巴科斯范式")]),a._v(" "),r("ul",[r("li",[a._v("BNF(Backus-Naur Form)是描述编程语言的文法。巴科斯范式是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。")]),a._v(" "),r("li",[a._v("语法")])]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v('< >     : 内包含的为必选项。\n[ ]     : 内包含的为可选项。\n{ }     : 内包含的为可重复0至无数次的项。\n|       : 表示在其左右两边任选一项，相当于"OR"的意思。\n::=     : 是“被定义为”的意思\n"..."   : 术语符号\n[...]   : 选项，最多出现一次\n{...}   : 重复项，任意次数，包括 0 次\n(...)   : 分组\n|       : 并列选项，只能选一个\n')])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br"),r("span",{staticClass:"line-number"},[a._v("6")]),r("br"),r("span",{staticClass:"line-number"},[a._v("7")]),r("br"),r("span",{staticClass:"line-number"},[a._v("8")]),r("br"),r("span",{staticClass:"line-number"},[a._v("9")]),r("br"),r("span",{staticClass:"line-number"},[a._v("10")]),r("br")])]),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v('Java 的for循环的BNF范式表达：\n\nFOR_STATEMENT ::=\n    "for" "(" ( variable_declaration |\n    ( expression ";" ) | ";" )\n    [ expression ] ";"\n    [ expression ]\n    ")" statement\n')])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br"),r("span",{staticClass:"line-number"},[a._v("6")]),r("br"),r("span",{staticClass:"line-number"},[a._v("7")]),r("br"),r("span",{staticClass:"line-number"},[a._v("8")]),r("br")])]),r("ul",[r("li",[a._v("Json的BNF范式\n"),r("img",{attrs:{src:t(359),alt:"image"}})])]),a._v(" "),r("h2",{attrs:{id:"syntax-diagrams-railroad-diagrams"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#syntax-diagrams-railroad-diagrams"}},[a._v("#")]),a._v(" Syntax diagrams | railroad diagrams")]),a._v(" "),r("ul",[r("li",[a._v("Syntax diagrams (or railroad diagrams) are a way to represent a context-free grammar.")]),a._v(" "),r("li")]),a._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v('<expression> ::= <term> | <term> "+" <expression>\n<term>       ::= <factor> | <factor> "*" <term>\n<factor>     ::= <constant> | <variable> | "(" <expression> ")"\n<variable>   ::= "x" | "y" | "z" \n<constant>   ::= <digit> | <digit> <constant>\n<digit>      ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"\n')])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br"),r("span",{staticClass:"line-number"},[a._v("3")]),r("br"),r("span",{staticClass:"line-number"},[a._v("4")]),r("br"),r("span",{staticClass:"line-number"},[a._v("5")]),r("br"),r("span",{staticClass:"line-number"},[a._v("6")]),r("br")])]),r("p",[r("img",{attrs:{src:t(360),alt:"image"}})]),a._v(" "),r("h3",{attrs:{id:"数据库范式-六个"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据库范式-六个"}},[a._v("#")]),a._v(" 数据库范式 (六个)")]),a._v(" "),r("ul",[r("li",[a._v("第一范式（1NF）")]),a._v(" "),r("li",[a._v("第二范式（2NF）")]),a._v(" "),r("li",[a._v("第三范式（3NF）")]),a._v(" "),r("li",[a._v("巴斯-科德范式（BCNF）")]),a._v(" "),r("li",[a._v("第四范式(4NF）")]),a._v(" "),r("li",[a._v("第五范式（5NF，又称完美范式）")])]),a._v(" "),r("h2",{attrs:{id:"计算机中的体现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#计算机中的体现"}},[a._v("#")]),a._v(" 计算机中的体现")]),a._v(" "),r("ul",[r("li",[a._v("AST(Abstract Syntax Tree)，抽象语法树")])]),a._v(" "),r("h2",{attrs:{id:"正则表达式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[a._v("#")]),a._v(" 正则表达式")]),a._v(" "),r("ul",[r("li",[a._v("正则表达式是一种特殊形式的语法，用于解析字符串和其他文本信息，这些信息在形式语言理论中被称为“规则语言”。")])]),a._v(" "),r("h4",{attrs:{id:"正则语言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#正则语言"}},[a._v("#")]),a._v(" 正则语言")]),a._v(" "),r("ul",[r("li",[a._v("形式语言与自动机理论中讨论的最基本的语言系。通过它可以架起有穷自动机和正则表达式之间的一座桥梁。")]),a._v(" "),r("li",[a._v("编程语言通常定义为"),r("a",{attrs:{href:"#%E5%9B%BE%E7%81%B5%E6%9C%BA"}},[a._v("Turing Complete")]),a._v("的语言。这样的语言必须能够处理任何可计算的功能。正则表达式不适用于此类别。")])]),a._v(" "),r("h4",{attrs:{id:"理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#理解"}},[a._v("#")]),a._v(" 理解")]),a._v(" "),r("ul",[r("li",[a._v("正则是一种描述方式，只不过不是图灵完备的描述方式，因为不具备图灵完备性")]),a._v(" "),r("li",[a._v('所有根据具体的需求可以生产某种"形式语言"来解决具体的问题')]),a._v(" "),r("li",[a._v("不要眼中只有代码")])]),a._v(" "),r("h2",{attrs:{id:"计算理论的发展"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#计算理论的发展"}},[a._v("#")]),a._v(" 计算理论的发展")]),a._v(" "),r("ul",[r("li",[a._v("有限状态机 => 上下文无关语法 => 图灵机 => 现代计算机")]),a._v(" "),r("li",[a._v("逐步发展为可以计算世界上可计算之事")])]),a._v(" "),r("h2",{attrs:{id:"图灵机"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#图灵机"}},[a._v("#")]),a._v(" 图灵机")]),a._v(" "),r("ul",[r("li",[r("img",{attrs:{src:t(361),alt:"image"}})]),a._v(" "),r("li",[r("img",{attrs:{src:"http://morphett.info/turing/turing.html",alt:"模拟器"}})])]),a._v(" "),r("h4",{attrs:{id:"图灵完备"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#图灵完备"}},[a._v("#")]),a._v(" 图灵完备")]),a._v(" "),r("ul",[r("li",[a._v("图灵试图寻找一种世界上所有计算问题的解决方案，一篮子解决世界上所有的计算问题。")]),a._v(" "),r("li",[a._v("如果一个计算机语言具有图灵完备性（Turing Completeness），那么这个语言就是图灵完备语言（Turing-complete language）。")]),a._v(" "),r("li",[a._v("如果一门编程语言、一个指令集可实现图灵机模型里面全部的功能，或者说能够满足任意数据按照一定顺序计算出结果，我们就可称其具有图灵完备性。")]),a._v(" "),r("li",[a._v("常见的编程语言都是图灵完备语言, 而SQL也是图灵完备语言")]),a._v(" "),r("li",[a._v("而JSON、HTML都不是图灵完备语言")]),a._v(" "),r("li",[a._v("图灵机的所有可能状态的数目是有限的，并且有一个特殊的状态，称为停机状态。")]),a._v(" "),r("li",[a._v("如果一个语言是图灵完备性语言，则意味着一种语言能解决的问题，在另外一种语言中也可以计算出来。证明两个计算模型{\\displaystyle A}A和{\\displaystyle B}B的计算能力等价的基本思想是：用{\\displaystyle A}A和{\\displaystyle B}B相互模拟，若{\\displaystyle A}A可模拟{\\displaystyle B}B且{\\displaystyle B}B可模拟{\\displaystyle A}A，显然他们的计算能力等价。")])]),a._v(" "),r("h4",{attrs:{id:"图灵测试"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#图灵测试"}},[a._v("#")]),a._v(" 图灵测试")]),a._v(" "),r("ul",[r("li",[r("img",{attrs:{src:t(362),alt:"image"}})])]),a._v(" "),r("h2",{attrs:{id:"有限状态机"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#有限状态机"}},[a._v("#")]),a._v(" 有限状态机")]),a._v(" "),r("ul",[r("li",[a._v("有限状态机, FSM:finite-state machine， FSA:finite-state automaton")]),a._v(" "),r("li",[a._v("为什么说是machine？")]),a._v(" "),r("li",[a._v("一种计算的数学模型")]),a._v(" "),r("li",[a._v("组成： 状态列表、初始状态、每个转换的条件")]),a._v(" "),r("li",[a._v("类型： 确定性有限状态机(DFA)和非确定性有限状态机(NFA)")]),a._v(" "),r("li",[a._v("在计算机科学中，有限状态机广泛应用于应用行为建模、硬件数字系统设计、软件工程、编译器、网络协议以及计算和语言研究。")])]),a._v(" "),r("h4",{attrs:{id:"弱点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#弱点"}},[a._v("#")]),a._v(" 弱点")]),a._v(" "),r("ul",[r("li",[a._v("每一种有限状态机均功能唯一，即设计好之后无法完成其他原理不同的工作")]),a._v(" "),r("li",[a._v("因为其状态有限，当所要描述的系统的状态太多时，可能确定的有限状态机无能为力")]),a._v(" "),r("li",[a._v("有一些任务是有限状态机无法完成的，比如它可以判断输入的0、1数列中0或1的个数是否为奇数或偶数，但是无法判断0是否比1多或者相反")])]),a._v(" "),r("h4",{attrs:{id:"功能限制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#功能限制"}},[a._v("#")]),a._v(" 功能限制")]),a._v(" "),r("ul",[r("li",[a._v("有限状态机不但状态有限，功能也有限")]),a._v(" "),r("li",[a._v("根据计算理论，这是因为它只能接受正则语言，而正则语言是最低级的语言，所以能够解决的问题是有限的")])]),a._v(" "),r("h4",{attrs:{id:"确定性有限自动机"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#确定性有限自动机"}},[a._v("#")]),a._v(" 确定性有限自动机")]),a._v(" "),r("ul",[r("li",[a._v("给定当前状态和输入，下一个状态是唯一且确定的。")])]),a._v(" "),r("h4",{attrs:{id:"与图灵机的不同"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#与图灵机的不同"}},[a._v("#")]),a._v(" 与图灵机的不同")]),a._v(" "),r("ul",[r("li",[a._v("图灵机可以根据状态转移规则把1001翻转成0110或者其他不同的二进制串，而这是DFA或者FSM做不到的，它们只可以做匹配和简单的映射。")])]),a._v(" "),r("h4",{attrs:{id:"理解-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#理解-2"}},[a._v("#")]),a._v(" 理解")]),a._v(" "),r("ul",[r("li",[a._v("状态机更侧重于几种状态间的有限切换")]),a._v(" "),r("li",[a._v("图灵机则可以做更复杂的计算")])]),a._v(" "),r("h4",{attrs:{id:"正则表达式与有限自动机及正则文法的关系"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式与有限自动机及正则文法的关系"}},[a._v("#")]),a._v(" 正则表达式与有限自动机及正则文法的关系")]),a._v(" "),r("ul",[r("li",[a._v("三者功能是等价的。DFA与NFA之间可以相互转换，而正则表达式可以方便地构造，自动机，及正则文法（一般的编译原理或形式语言教材上都有例子）")]),a._v(" "),r("li",[a._v("A regular expressions and FSM’s are equivalent concepts. Regular expression is a pattern that can berecognized by a FSM. Regex is an example of how good theory leadsto good programs")])]),a._v(" "),r("h4",{attrs:{id:"正则文法与上下文无关文法的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#正则文法与上下文无关文法的区别"}},[a._v("#")]),a._v(" 正则文法与上下文无关文法的区别")]),a._v(" "),r("ul",[r("li",[a._v("正则文法对应有限自动机，上下文无关文法对应下推自动机（有限自动机的扩展）。有限自动机只对终结符做状态转移，而下推机，可以对非终结符做状态转移。")])]),a._v(" "),r("h2",{attrs:{id:"lex-yacc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lex-yacc"}},[a._v("#")]),a._v(" Lex && Yacc")]),a._v(" "),r("h2",{attrs:{id:"reference"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reference"}},[a._v("#")]),a._v(" reference")]),a._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"http://www.cs.cmu.edu/~ab/15-123S10/AnnotatedNotes/Lecture19-12PM.pdf",target:"_blank",rel:"noopener noreferrer"}},[a._v("regular express & fsm"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=e.exports}}]);